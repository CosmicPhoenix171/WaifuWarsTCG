<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Waifu Wars TCG ‚Äì Emotional Strategy Card Game</title>
  <meta name="description" content="Waifu Wars TCG: fast tactical anime card game where Bonds, moods, and archetypes forge dramatic comebacks." />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#ee2e8b" />
  <meta property="og:title" content="Waifu Wars TCG" />
  <meta property="og:description" content="Tactical anime card battler with bonds, mood states, and archetype matchups." />
  <meta property="og:type" content="website" />
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%236d5dfc'/%3E%3Cpath d='M20 38c6 6 12 6 18 0 5-5 5-13 0-18-4-4-10-4-14 0-5 5-5 13 0 18z' fill='%23fff'/%3E%3C/svg%3E" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="cards.css" />
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>
  <header class="site-header">
    <div class="container nav">
      <div class="brand">
        <span class="logo">Waifu Wars</span>
        <span class="tag">TCG</span>
      </div>
      <nav class="menu" aria-label="Primary">
        <a href="#splash">Overview</a>
        <a href="#lore-index">Lore Index</a>
        <a href="#cards">Cards</a>
        <a href="#join">Join</a>
      </nav>
    </div>
  </header>

  <main id="main">
    <section class="splash-hero" id="splash">
      <div class="splash-hero__glow" aria-hidden="true"></div>
      <div class="container splash-hero__inner">
        <div class="splash-copy">
          <p class="splash-eyebrow">Emotional Strategy TCG</p>
          <h1 class="splash-title">Outplay With Bonds</h1>
          <p class="splash-subtitle">Draft dere personalities, flip mood states mid-match, and unleash bond-driven finishers in a web-native anime card experience.</p>
          <div class="splash-actions">
            <a class="btn btn-primary" href="#cards">See Card Spotlight</a>
            <a class="btn btn-ghost" href="#lore-index">Explore the World</a>
          </div>
          <ul class="splash-highlights">
            <li>Bond costs replace energy to pace your power spikes.</li>
            <li>Mood swings unlock alternate art and upgraded abilities.</li>
            <li>Play in-browser with tactile card flipping and hover tilt.</li>
          </ul>
        </div>
        <div class="splash-showcase" aria-hidden="true">
          <div class="splash-card splash-card--front">
            <span class="splash-card-rarity">SR</span>
            <span class="splash-card-name">Crown Himedere</span>
            <span class="splash-card-tag">Leader ‚Ä¢ Inspire</span>
          </div>
          <div class="splash-card splash-card--mid">
            <span class="splash-card-rarity">SSR</span>
            <span class="splash-card-name">Domination Kamidere</span>
            <span class="splash-card-tag">Charm ‚Ä¢ Control</span>
          </div>
          <div class="splash-card splash-card--back">
            <span class="splash-card-rarity">R</span>
            <span class="splash-card-name">Sunbeam Deredere</span>
            <span class="splash-card-tag">Heal ‚Ä¢ Support</span>
          </div>
        </div>
      </div>
    </section>

    <section id="lore-index" class="info-section">
      <div class="container">
        <h2 class="section-title">Know Your Lineup</h2>
        <p class="info-intro">Plan team synergy at a glance. Each chart highlights species rosters, combat keywords, and the dere personalities powering your bond plays.</p>
        <div class="info-tabs" role="tablist" aria-label="Lore Index Tabs" data-tabs>
          <button type="button" class="info-tab is-active" id="tab-species" role="tab" aria-selected="true" aria-controls="species-panel" data-tab-target="species-panel">Species Lineup</button>
          <button type="button" class="info-tab" id="tab-effects" role="tab" aria-selected="false" aria-controls="effects-panel" data-tab-target="effects-panel" tabindex="-1">Effect Types</button>
          <button type="button" class="info-tab" id="tab-dere" role="tab" aria-selected="false" aria-controls="dere-panel" data-tab-target="dere-panel" tabindex="-1">Dere Archetypes</button>
        </div>
        <div class="info-panels">
          <section class="info-panel" role="tabpanel" id="species-panel" aria-labelledby="tab-species">
            <h3>Species Lineup</h3>
            <p class="info-panel-copy">Every species leans into a unique combat fantasy‚Äîmix and match to balance raw power, control tricks, and narrative flair.</p>
            <div class="table-scroll" role="group" aria-labelledby="species-table-caption">
              <table class="info-table" id="species-table">
                <caption id="species-table-caption" class="sr-only">Species options and their core descriptions</caption>
                <thead>
                  <tr>
                    <th scope="col">Species</th>
                    <th scope="col">Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th scope="row">Human</th>
                    <td>Baseline; no inherent bonus or penalty.</td>
                  </tr>
                  <tr>
                    <th scope="row">Elf</th>
                    <td>Nature-linked, wise and graceful.</td>
                  </tr>
                  <tr>
                    <th scope="row">Kitsune</th>
                    <td>Illusionist tricksters; clever and seductive.</td>
                  </tr>
                  <tr>
                    <th scope="row">Demon</th>
                    <td>Dark power users; chaotic but strong.</td>
                  </tr>
                  <tr>
                    <th scope="row">Angel</th>
                    <td>Holy beings of purity and protection.</td>
                  </tr>
                  <tr>
                    <th scope="row">Vampire</th>
                    <td>Life-draining predators; elegant yet tragic.</td>
                  </tr>
                  <tr>
                    <th scope="row">Android</th>
                    <td>Artificial waifus; logical and emotion-learning.</td>
                  </tr>
                  <tr>
                    <th scope="row">Slime</th>
                    <td>Adaptive and underestimated shapeshifters.</td>
                  </tr>
                  <tr>
                    <th scope="row">Succubus</th>
                    <td>Seductive energy manipulators.</td>
                  </tr>
                  <tr>
                    <th scope="row">Neko (Catgirl)</th>
                    <td>Playful, mischievous, cute but dangerous.</td>
                  </tr>
                  <tr>
                    <th scope="row">Dragonkin</th>
                    <td>Proud, powerful, ancient bloodline.</td>
                  </tr>
                  <tr>
                    <th scope="row">Fairy</th>
                    <td>Magical and supportive; small but potent.</td>
                  </tr>
                  <tr>
                    <th scope="row">Mermaid</th>
                    <td>Songstress of the sea, gentle healer type.</td>
                  </tr>
                  <tr>
                    <th scope="row">Ghost</th>
                    <td>Ethereal beings tied to emotion.</td>
                  </tr>
                  <tr>
                    <th scope="row">Witch</th>
                    <td>Spellcasters with knowledge-based magic.</td>
                  </tr>
                  <tr>
                    <th scope="row">Idol</th>
                    <td>Performers powered by admiration and fame.</td>
                  </tr>
                  <tr>
                    <th scope="row">Goddess</th>
                    <td>Divine entities with immense but costly power.</td>
                  </tr>
                  <tr>
                    <th scope="row">Alien</th>
                    <td>Mysterious off-world beings with random effects.</td>
                  </tr>
                  <tr>
                    <th scope="row">Zombie</th>
                    <td>Cute corpses with resistance to debuffs.</td>
                  </tr>
                  <tr>
                    <th scope="row">Magical Girl</th>
                    <td>Hopeful heroes of light and friendship.</td>
                  </tr>
                  <tr>
                    <th scope="row">Hybrid</th>
                    <td>Combines two species traits with mixed bonuses.</td>
                  </tr>
                  <tr>
                    <th scope="row">Deity</th>
                    <td>Godlike form with unique dual effects (event/ultra rare).</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section class="info-panel" role="tabpanel" id="effects-panel" aria-labelledby="tab-effects" hidden>
            <h3>Effect Types</h3>
            <p class="info-panel-copy">These keywords frame most card text‚Äîstack combos that layer damage, disruption, and protection.</p>
            <div class="table-scroll" role="group" aria-labelledby="effects-table-caption">
              <table class="info-table" id="effects-table">
                <caption id="effects-table-caption" class="sr-only">Effect keywords with their core functions</caption>
                <thead>
                  <tr>
                    <th scope="col">Effect Type</th>
                    <th scope="col">Core Function</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th scope="row">Burn üî•</th>
                    <td>Deals damage over time.</td>
                  </tr>
                  <tr>
                    <th scope="row">Poison ‚ò†Ô∏è</th>
                    <td>Ignores defenses; damages each turn.</td>
                  </tr>
                  <tr>
                    <th scope="row">Heal üíö</th>
                    <td>Restores Affection to allies.</td>
                  </tr>
                  <tr>
                    <th scope="row">Charm üíò</th>
                    <td>Disables, converts, or distracts an enemy.</td>
                  </tr>
                  <tr>
                    <th scope="row">Shield üõ°Ô∏è</th>
                    <td>Blocks or reduces incoming damage.</td>
                  </tr>
                  <tr>
                    <th scope="row">Drain ü©∏</th>
                    <td>Steals AFF (HP) or BP from target.</td>
                  </tr>
                  <tr>
                    <th scope="row">Freeze ‚ùÑÔ∏è</th>
                    <td>Prevents enemy action for one turn.</td>
                  </tr>
                  <tr>
                    <th scope="row">Boost ‚ö°</th>
                    <td>Raises Bond or Affection temporarily.</td>
                  </tr>
                  <tr>
                    <th scope="row">Curse üïØÔ∏è</th>
                    <td>Reduces enemy power or healing.</td>
                  </tr>
                  <tr>
                    <th scope="row">Resurrect üåô</th>
                    <td>Revives a defeated ally.</td>
                  </tr>
                  <tr>
                    <th scope="row">Copy üåÄ</th>
                    <td>Copies another card‚Äôs ability.</td>
                  </tr>
                  <tr>
                    <th scope="row">Pierce üí¢</th>
                    <td>Ignores shields or defense.</td>
                  </tr>
                  <tr>
                    <th scope="row">Cleanse üíß</th>
                    <td>Removes debuffs or negative effects.</td>
                  </tr>
                  <tr>
                    <th scope="row">Silence üîá</th>
                    <td>Blocks an enemy‚Äôs ability activation.</td>
                  </tr>
                  <tr>
                    <th scope="row">Summon ‚ú®</th>
                    <td>Calls a Support or temporary clone.</td>
                  </tr>
                  <tr>
                    <th scope="row">Steal üíé</th>
                    <td>Takes BP or buffs from enemy.</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section class="info-panel" role="tabpanel" id="dere-panel" aria-labelledby="tab-dere" hidden>
            <h3>Dere Archetypes</h3>
            <p class="info-panel-copy">Personality drives tactics‚Äîdraft dere types that reinforce your win condition.</p>
            <div class="table-scroll" role="group" aria-labelledby="dere-table-caption">
              <table class="info-table" id="dere-table">
                <caption id="dere-table-caption" class="sr-only">Dere archetypes with symbols, battle traits, and synergies</caption>
                <thead>
                  <tr>
                    <th scope="col">Dere Type</th>
                    <th scope="col">Symbol</th>
                    <th scope="col">Personality Summary</th>
                    <th scope="col">Core Trait in Battle</th>
                    <th scope="col">Ability Synergy</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th scope="row">Tsundere</th>
                    <td>üî•</td>
                    <td>Acts hostile or embarrassed to hide affection.</td>
                    <td>Prideful offense, emotional defense.</td>
                    <td>Burn, Boost, Shield</td>
                  </tr>
                  <tr>
                    <th scope="row">Yandere</th>
                    <td>üíî</td>
                    <td>Deeply obsessed, jealous, violent if love is threatened.</td>
                    <td>Sacrifices Affection for power.</td>
                    <td>Drain, Curse, Charm</td>
                  </tr>
                  <tr>
                    <th scope="row">Kuudere</th>
                    <td>‚ùÑÔ∏è</td>
                    <td>Cold and calm, shows warmth privately.</td>
                    <td>Consistent, unshakable control.</td>
                    <td>Freeze, Shield, Pierce</td>
                  </tr>
                  <tr>
                    <th scope="row">Dandere</th>
                    <td>üå∏</td>
                    <td>Shy, soft-spoken, loyal and patient.</td>
                    <td>Healer and quiet support.</td>
                    <td>Heal, Boost, Cleanse</td>
                  </tr>
                  <tr>
                    <th scope="row">Deredere</th>
                    <td>üíï</td>
                    <td>Cheerful, affectionate, pure-hearted optimist.</td>
                    <td>Buffs allies through love.</td>
                    <td>Boost, Heal, Charm</td>
                  </tr>
                  <tr>
                    <th scope="row">Himedere</th>
                    <td>üëë</td>
                    <td>Regal, demands admiration and loyalty.</td>
                    <td>Leader archetype; commands others.</td>
                    <td>Shield, Charm, Pierce</td>
                  </tr>
                  <tr>
                    <th scope="row">Kamidere</th>
                    <td>‚ú®</td>
                    <td>God-complex, absolute authority, power-driven.</td>
                    <td>Massive BP spikes; risks backfire.</td>
                    <td>Curse, Burn, Boost</td>
                  </tr>
                  <tr>
                    <th scope="row">Utsudere</th>
                    <td>üïØÔ∏è</td>
                    <td>Depressed, gloomy, emotionally fragile.</td>
                    <td>Self-damaging but strong healing synergy.</td>
                    <td>Drain, Heal, Curse</td>
                  </tr>
                  <tr>
                    <th scope="row">Bakadere</th>
                    <td>ü´∂</td>
                    <td>Clumsy, airheaded, sweetly naive.</td>
                    <td>Random BP surges; unpredictable.</td>
                    <td>Boost, Heal, Charm</td>
                  </tr>
                  <tr>
                    <th scope="row">Mayadere</th>
                    <td>üï∏Ô∏è</td>
                    <td>Villainess who turns good after bonding.</td>
                    <td>Strong early offense, late support.</td>
                    <td>Drain, Boost, Heal</td>
                  </tr>
                  <tr>
                    <th scope="row">Darudere</th>
                    <td>üò¥</td>
                    <td>Lazy, chill, easygoing.</td>
                    <td>Low BP gain, immune to stress effects.</td>
                    <td>Shield, Heal, Copy</td>
                  </tr>
                  <tr>
                    <th scope="row">Yangire</th>
                    <td>üíÄ</td>
                    <td>Violent like Yandere but without love focus.</td>
                    <td>Raw chaos power.</td>
                    <td>Burn, Curse, Drain</td>
                  </tr>
                  <tr>
                    <th scope="row">Hinedere</th>
                    <td>‚ö´</td>
                    <td>Cynical, rude, hides caring side.</td>
                    <td>Reduces opponent BP efficiency.</td>
                    <td>Pierce, Burn, Curse</td>
                  </tr>
                  <tr>
                    <th scope="row">Oujoudere</th>
                    <td>üëí</td>
                    <td>Elegant, well-mannered noble type.</td>
                    <td>Improves ally synergy; stable buff source.</td>
                    <td>Boost, Shield, Heal</td>
                  </tr>
                  <tr>
                    <th scope="row">Nyandere</th>
                    <td>üêæ</td>
                    <td>Catlike personality ‚Äî playful, affectionate but moody.</td>
                    <td>Gains BP randomly; risk/reward playstyle.</td>
                    <td>Charm, Boost, Burn</td>
                  </tr>
                  <tr>
                    <th scope="row">Shundere</th>
                    <td>üåßÔ∏è</td>
                    <td>Sad, withdrawn, pessimistic, but kind-hearted.</td>
                    <td>Emotional support, regenerates BP slowly.</td>
                    <td>Heal, Drain, Curse</td>
                  </tr>
                  <tr>
                    <th scope="row">Kekkondere</th>
                    <td>üíç</td>
                    <td>Desperately wants marriage or long-term bond.</td>
                    <td>Bond-based power multiplier.</td>
                    <td>Boost, Charm, Drain</td>
                  </tr>
                  <tr>
                    <th scope="row">Nemuidere</th>
                    <td>üò¥üí§</td>
                    <td>Sleepy, peaceful, carefree waifu.</td>
                    <td>Starts with low BP but regenerates passively.</td>
                    <td>Heal, Shield, Boost</td>
                  </tr>
                  <tr>
                    <th scope="row">Byoukidere</th>
                    <td>üíä</td>
                    <td>Ill or fragile health, endures through pain.</td>
                    <td>Gains BP when taking damage.</td>
                    <td>Heal, Drain, Boost</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </div>
      </div>
    </section>

    <div id="cards-section" data-partial="cards"></div>

    <section class="callouts">
      <div class="container">
        <div class="callout">
          <div class="callout-copy">
            <h3>Meet the Archetypes</h3>
            <p>Learn the macro families‚ÄîPassion Surge, Stoic Control, Heart Guard‚Äîand how they create soft matchups.</p>
            <a class="btn btn-secondary" href="#lore-index">Explore Archetypes</a>
          </div>
        </div>
        <div class="callout alt">
          <div class="callout-copy">
            <h3>Build Your First Deck</h3>
            <p>Start with a Tsundere reactive shell or a Deredere support core‚Äîsimple rules, deep strategy.</p>
            <a class="btn btn-secondary" href="#cards">See Cards</a>
          </div>
        </div>
      </div>
    </section>

    <section id="join" class="cta">
      <div class="container">
        <h2 class="section-title">Join The Journey</h2>
        <p>Follow development and get notified when the alpha opens.</p>
        <div class="cta-row">
          <a class="btn btn-primary" href="#">Join Waitlist</a>
          <a class="btn btn-ghost" href="#lore-index">Learn More</a>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <div>¬© <span id="year"></span> Waifu Wars TCG</div>
      <div class="footer-links">
        <a href="#join">Contact</a>
        <a href="https://github.com/CosmicPhoenix171/WaifuWarsTCG" target="_blank" rel="noopener">GitHub</a>
      </div>
    </div>
  </footer>

  <script type="module">
    // === DOM REFERENCES ===
  const yearEl = document.getElementById('year');
  const cardsSectionMount = document.getElementById('cards-section');
  let cardsGrid = null;
  let cardsStatus = null;

    if (yearEl) {
      yearEl.textContent = new Date().getFullYear();
    }

    // === CONFIGURATION ===
  const RARITY_META = {
      common: {
        key: 'common',
        datasetKey: 'common',
        name: 'Common',
        code: 'C',
        symbol: '‚óè',
        stars: '‚Ä¢'
      },
      rare: {
        key: 'rare',
        datasetKey: 'rare',
        name: 'Rare',
        code: 'R',
        symbol: '‚òÖ',
        stars: '‚òÖ'
      },
      'super-rare': {
        key: 'super-rare',
        datasetKey: 'super-rare',
        name: 'Super Rare',
        code: 'SR',
        symbol: '‚òÖ‚òÖ',
        stars: '‚òÖ‚òÖ'
      },
      'special-super-rare': {
        key: 'special-super-rare',
        datasetKey: 'special-super-rare',
        name: 'Special Super Rare',
        code: 'SSR',
        symbol: '‚òÖ‚òÖ‚òÖ',
        stars: '‚òÖ‚òÖ‚òÖ'
      },
      ultra: {
        key: 'ultra',
        datasetKey: 'ultra',
        name: 'Ultra Rare',
        code: 'UR',
        symbol: '‚ú™',
        stars: '‚ú™'
      },
      event: {
        key: 'event',
        datasetKey: 'ultra',
        name: 'Event Exclusive',
        code: 'EX',
        symbol: '‚ú™',
        stars: '‚ú™'
      }
    };

    // === UTILITY HELPERS ===
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function escapeHtml(str = '') {
      return String(str).replace(/[&<>"']/g, (ch) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[ch]));
    }

    function capitalize(word = '') {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }

    function formatSentences(text) {
      if (!text) {
        return [];
      }
      return String(text)
        .split(/(?:\r?\n|\r)+|(?<=[.!?])\s+/)
        .map((line) => line.trim())
        .filter(Boolean);
    }

    function prettifyLabel(value = '') {
      return value
        .toString()
        .replace(/[_-]+/g, ' ')
        .replace(/\b\w/g, (ch) => ch.toUpperCase())
        .trim();
    }

    function parseNumericBondValue(value) {
      if (typeof value === 'number' && Number.isFinite(value)) {
        return value;
      }
      if (typeof value === 'string' && value.trim().length) {
        const parsed = Number(value);
        if (Number.isFinite(parsed)) {
          return parsed;
        }
      }
      return null;
    }

    function getPrimaryRole(card = {}) {
      if (!card) {
        return '';
      }
      if (card.role) {
        return card.role;
      }
      if (typeof card.strategy === 'string' && card.strategy.trim().length) {
        return card.strategy;
      }
      return '';
    }

    function arrangeTopRowRarities(cards = []) {
      if (!Array.isArray(cards) || cards.length === 0) {
        return [];
      }

      const priorityOrder = [
        'common',
        'rare',
        'super-rare',
        'special-super-rare',
        'ultra',
        'event'
      ];
      const used = new Set();
      const prioritized = [];
      const lowerRarities = cards.map((card) => (card?.rarity || '').toLowerCase());
      const topRowSlots = Math.min(3, cards.length);

      for (const rarity of priorityOrder) {
        const index = lowerRarities.findIndex((value, idx) => value === rarity && !used.has(idx));
        if (index >= 0) {
          prioritized.push(cards[index]);
          used.add(index);
          if (prioritized.length >= topRowSlots) {
            break;
          }
        }
      }

      if (!used.size) {
        return cards.slice();
      }

      cards.forEach((card, idx) => {
        if (!used.has(idx)) {
          prioritized.push(card);
        }
      });

      return prioritized;
    }

    function decorateAbilityText(text = '') {
      let output = escapeHtml(text);
      const replacements = [
        { pattern: /\{?BOND\}?/gi, markup: '<span class="card-icon card-icon--bond" aria-hidden="true"></span><span class="sr-only">Bond</span>' },
        { pattern: /\bATK\b/g, markup: '<span class="card-icon card-icon--atk" aria-hidden="true"></span><span class="sr-only">Attack</span>' },
        { pattern: /\bDEF\b/g, markup: '<span class="card-icon card-icon--def" aria-hidden="true"></span><span class="sr-only">Defense</span>' },
        { pattern: /\bHP\b/gi, markup: '<span class="card-icon card-icon--hp" aria-hidden="true"></span><span class="sr-only">Health</span>' },
        { pattern: /\bAFFECTION\b/gi, markup: '<span class="card-icon card-icon--aff" aria-hidden="true"></span><span class="sr-only">Affection</span>' }
      ];
      replacements.forEach(({ pattern, markup }) => {
        output = output.replace(pattern, markup);
      });
      return output;
    }

    function renderBondCostHearts(count, labelText = null) {
      const srBase = labelText ? String(labelText) : 'Bond cost';
      if (!Number.isFinite(count)) {
        return `<span class="card-cost-hearts card-cost-hearts--empty" aria-hidden="true"><span class="card-cost-heart" aria-hidden="true"></span></span><span class="sr-only">${srBase} unavailable</span>`;
      }

      const rounded = Math.round(count);
      if (rounded <= 0) {
        return `<span class="card-cost-hearts card-cost-hearts--empty" aria-hidden="true"><span class="card-cost-heart" aria-hidden="true"></span></span><span class="sr-only">${srBase} 0 hearts</span>`;
      }

      const total = clamp(rounded, 1, 5);
      const icons = Array.from({ length: total })
        .map(() => '<span class="card-cost-heart" aria-hidden="true"></span>')
        .join('');
      const srLabel = `${srBase} ${total} heart${total === 1 ? '' : 's'}`;
      return `<span class="card-cost-hearts" aria-hidden="true">${icons}</span><span class="sr-only">${srLabel}</span>`;
    }

    function parseKeywordCost(keyword = '') {
      if (!keyword) {
        return { label: '', cost: null };
      }

      const trimmed = keyword.trim();
      const parenMatch = trimmed.match(/^(.*?)[\s]*\((\d+)\)\s*$/);
      if (parenMatch) {
        return { label: parenMatch[1].trim(), cost: Number(parenMatch[2]) };
      }

      const trailingMatch = trimmed.match(/^(.*?)[\s]+(\d+)$/);
      if (trailingMatch) {
        return { label: trailingMatch[1].trim(), cost: Number(trailingMatch[2]) };
      }

      return { label: trimmed, cost: null };
    }

    function formatAbilityLine(line = '', bondCosts = {}) {
      const trimmed = line.trim();
      if (!trimmed) {
        return null;
      }
      const keywordMatch = trimmed.match(/^([^:\u2014\u2013\-]{1,48}?)[\s]*(?:[:\u2014\u2013\-])\s+(.+)$/u);
      if (keywordMatch) {
        const keywordRaw = keywordMatch[1].trim();
        const { label: parsedLabel, cost: parsedCost } = parseKeywordCost(keywordRaw);
        let keywordLabel = parsedLabel;
        const keywordId = keywordLabel.toLowerCase();
        let isCostKeyword = false;
        let costValue = parsedCost;
        if (keywordId === 'dere' || keywordId === 'extreme') {
          const costs = (bondCosts && typeof bondCosts === 'object') ? bondCosts : {};
          costValue = costs[keywordId];
          keywordLabel = 'Bond Cost';
          isCostKeyword = true;
        }
        const body = decorateAbilityText(keywordMatch[2]);
        if (isCostKeyword) {
          const costMarkup = renderBondCostHearts(costValue);
          return {
            html: `<span class="card-ability-keyword card-ability-keyword--cost">${costMarkup}</span><span class="card-ability-body">${body}</span>`,
            modifier: 'cost'
          };
        }
        if (costValue !== null) {
          const keywordText = decorateAbilityText(keywordLabel);
          const costMarkup = renderBondCostHearts(costValue, `${keywordLabel} cost`);
          return {
            html: `<span class="card-ability-keyword card-ability-keyword--cost"><span class="card-ability-cost-label">${keywordText}</span>${costMarkup}</span><span class="card-ability-body">${body}</span>`,
            modifier: 'cost'
          };
        }
        const keyword = decorateAbilityText(keywordLabel);
        return {
          html: `<span class="card-ability-keyword card-ability-keyword--block">${keyword}</span><span class="card-ability-body card-ability-body--stacked">${body}</span>`,
          modifier: 'stacked'
        };
      }
      return {
        html: `<span class="card-ability-body">${decorateAbilityText(trimmed)}</span>`,
        modifier: 'plain'
      };
    }

    // === LAYOUT HELPERS ===
    function getTextBoxAvailableHeight(textBox) {
      const boxStyle = getComputedStyle(textBox);
      const paddingTop = parseFloat(boxStyle.paddingTop) || 0;
      const paddingBottom = parseFloat(boxStyle.paddingBottom) || 0;
      return textBox.clientHeight - paddingTop - paddingBottom;
    }

    function autoFitTextBox(textBox) {
      if (!textBox || textBox.dataset.fluid === 'true') return;
      const content = textBox.querySelector('.card-text-content');
      if (!content) return;

      const abilities = content.querySelector('.card-abilities');
      if (abilities) {
        abilities.style.fontSize = '';
        abilities.style.lineHeight = '';
        abilities.style.gap = '';
      }
      const flavorEl = content.querySelector('.card-flavor');
      if (flavorEl) {
        flavorEl.style.display = '';
      }
      content.style.fontSize = '';

      const availableHeight = getTextBoxAvailableHeight(textBox);
      if (availableHeight <= 0) {
        return;
      }

      const computed = getComputedStyle(content);
      const baseFont = parseFloat(computed.fontSize) || 18;
      const maxAutoByHeight = Math.max((availableHeight || 0) * 0.24, baseFont + 6);
    const maxFont = Math.min(28, baseFont * 1.75, maxAutoByHeight);
    const hardMin = 8.5;
    const minFont = Math.max(hardMin, baseFont * 0.55);

      const fits = (size) => {
        content.style.fontSize = `${size}px`;
        const heightThreshold = availableHeight > 2 ? availableHeight - 1 : availableHeight;
        return Math.ceil(content.scrollHeight) <= Math.floor(heightThreshold);
      };

      delete textBox.dataset.autofit;

      if (!fits(minFont)) {
        let size = minFont;
        while (size > hardMin && !fits(size)) {
          size -= 0.5;
        }
        const finalSize = Math.max(size, hardMin);
        content.style.fontSize = `${finalSize}px`;
        if (!fits(finalSize)) {
          textBox.dataset.autofit = 'overflow';
        }
        return;
      }

      if (fits(maxFont)) {
        return;
      }

      let low = minFont;
      let high = maxFont;
      let best = minFont;

      while (high - low > 0.05) {
        const mid = (low + high) / 2;
        if (fits(mid)) {
          best = mid;
          low = mid + 0.05;
        } else {
          high = mid - 0.05;
        }
      }

      content.style.fontSize = `${best}px`;
    }

    function balanceAbilityText(root = document) {
      if (!root || typeof root.querySelectorAll !== 'function') return;
      root.querySelectorAll('.card-text-box').forEach(autoFitTextBox);
    }

    function fitCardTitle(titleEl) {
      if (!titleEl) return;
      // Preserve original inline values we touch
      const original = {
        display: titleEl.style.display,
        webkitLineClamp: titleEl.style.webkitLineClamp,
        lineClamp: titleEl.style.lineClamp,
        webkitBoxOrient: titleEl.style.webkitBoxOrient,
        overflow: titleEl.style.overflow,
        fontSize: titleEl.style.fontSize
      };

      const computed = getComputedStyle(titleEl);
      let fontSize = parseFloat(computed.fontSize) || 18;
      const minFont = 12; // don't go too tiny

      // Temporarily remove clamp to measure full height
      titleEl.style.display = 'block';
      titleEl.style.webkitLineClamp = 'unset';
      titleEl.style.lineClamp = 'unset';
      titleEl.style.webkitBoxOrient = 'unset';
      titleEl.style.overflow = 'visible';

      // Compute allowed height for two lines
      const lhPx = (() => {
        const lh = computed.lineHeight;
        const num = parseFloat(lh);
        if (lh.endsWith('px')) return num;
        // fallback: scale of font size
        return (parseFloat(computed.fontSize) || 18) * 1.3;
      })();
      const allowed = lhPx * 2.05; // slightly generous

      // Reduce font until fits within 2 lines
      while (titleEl.scrollHeight > allowed && fontSize > minFont) {
        fontSize -= 0.5;
        titleEl.style.fontSize = `${fontSize}px`;
      }

      // Restore clamp behavior
      titleEl.style.display = original.display || '-webkit-box';
      titleEl.style.webkitLineClamp = original.webkitLineClamp || '2';
      titleEl.style.lineClamp = original.lineClamp || '2';
      titleEl.style.webkitBoxOrient = original.webkitBoxOrient || 'vertical';
      titleEl.style.overflow = original.overflow || 'hidden';
      // Keep the adjusted fontSize
    }

    function fitAllTitles(root = document) {
      const titles = root.querySelectorAll('.card-title');
      titles.forEach(fitCardTitle);
    }
    // === OVERFLOW DETECTION ===
    function titleWouldOverflow(titleEl) {
      if (!titleEl) return false;
      const prev = {
        display: titleEl.style.display,
        webkitLineClamp: titleEl.style.webkitLineClamp,
        lineClamp: titleEl.style.lineClamp,
        webkitBoxOrient: titleEl.style.webkitBoxOrient,
        overflow: titleEl.style.overflow
      };
      const computed = getComputedStyle(titleEl);
      // Temporarily remove clamp & overflow to measure full height
      titleEl.style.display = 'block';
      titleEl.style.webkitLineClamp = 'unset';
      titleEl.style.lineClamp = 'unset';
      titleEl.style.webkitBoxOrient = 'unset';
      titleEl.style.overflow = 'visible';
      const lhPx = (() => {
        const lh = computed.lineHeight;
        const num = parseFloat(lh);
        if (lh.endsWith('px')) return num;
        return (parseFloat(computed.fontSize) || 18) * 1.3;
      })();
      const allowed = lhPx * 2.05;
      const wouldOverflow = titleEl.scrollHeight > allowed + 0.5;
      // restore
      titleEl.style.display = prev.display || '-webkit-box';
      titleEl.style.webkitLineClamp = prev.webkitLineClamp || '2';
      titleEl.style.lineClamp = prev.lineClamp || '2';
      titleEl.style.webkitBoxOrient = prev.webkitBoxOrient || 'vertical';
      titleEl.style.overflow = prev.overflow || 'hidden';
      return wouldOverflow;
    }

    function detectCardOverflow(article) {
      if (!article) return;
      const textBox = article.querySelector('.card-text-box');
      const title = article.querySelector('.card-title');
      let overflow = false;
      if (textBox) {
        const content = textBox.querySelector('.card-text-content');
        if (content) {
          const available = getTextBoxAvailableHeight(textBox);
          overflow = overflow || (Math.ceil(content.scrollHeight) > Math.floor(available) + 1);
        } else {
          overflow = overflow || (textBox.scrollHeight > textBox.clientHeight + 1);
        }
      }
      if (title) {
        overflow = overflow || titleWouldOverflow(title);
      }
      if (overflow) {
        article.dataset.overflow = 'true';
      } else {
        delete article.dataset.overflow;
      }
    }

    function detectAllOverflow(root = document) {
      const cards = root.querySelectorAll('.card-display');
      cards.forEach(detectCardOverflow);
    }

    // === INTERACTION ===
    function setupInteractiveCard(article) {
      const flipEl = article.querySelector('.card-flip');
      if (!flipEl) {
        return;
      }

      const state = {
        pointerId: null,
        startX: 0,
        startY: 0,
        isDragging: false,
        hasFlipped: false,
        isFlipped: flipEl.classList.contains('is-flipped'),
        resetTimer: null
      };

      article.setAttribute('aria-pressed', state.isFlipped ? 'true' : 'false');

      const maxTiltX = 10;
      const maxTiltY = 16;

      const updateCursorVars = (nx = 0, ny = 0) => {
        article.style.setProperty('--cursor-x', Number.isFinite(nx) ? nx.toFixed(3) : '0');
        article.style.setProperty('--cursor-y', Number.isFinite(ny) ? ny.toFixed(3) : '0');
      };
      updateCursorVars(0, 0);

      const resetTilt = (smooth = true) => {
        if (state.resetTimer) {
          clearTimeout(state.resetTimer);
          state.resetTimer = null;
        }

        if (smooth) {
          flipEl.style.transition = 'transform .26s ease, box-shadow .26s ease';
          flipEl.style.setProperty('--tilt-x', '0deg');
          flipEl.style.setProperty('--tilt-y', '0deg');
          flipEl.style.setProperty('--tilt-scale', '1');
          state.resetTimer = setTimeout(() => {
            flipEl.style.transition = '';
            state.resetTimer = null;
          }, 260);
        } else {
          flipEl.style.transition = '';
          flipEl.style.setProperty('--tilt-x', '0deg');
          flipEl.style.setProperty('--tilt-y', '0deg');
          flipEl.style.setProperty('--tilt-scale', '1');
        }

        updateCursorVars(0, 0);
      };

      const toggleFlip = () => {
        state.isFlipped = !state.isFlipped;
        flipEl.classList.toggle('is-flipped', state.isFlipped);
        article.setAttribute('aria-pressed', state.isFlipped ? 'true' : 'false');
      };

      const handleHoverTilt = (event) => {
        if (state.isDragging) {
          return;
        }

        const rect = flipEl.getBoundingClientRect();
        const relativeX = (event.clientX - rect.left) / rect.width;
        const relativeY = (event.clientY - rect.top) / rect.height;
        const tiltY = clamp((relativeX - 0.5) * 2 * maxTiltY, -maxTiltY, maxTiltY);
        const tiltX = clamp((0.5 - relativeY) * 2 * maxTiltX, -maxTiltX, maxTiltX);
        const normX = clamp((relativeX - 0.5) * 2, -1, 1);
        const normY = clamp((0.5 - relativeY) * 2, -1, 1);

        flipEl.style.setProperty('--tilt-x', `${tiltX.toFixed(2)}deg`);
        flipEl.style.setProperty('--tilt-y', `${tiltY.toFixed(2)}deg`);
        flipEl.style.setProperty('--tilt-scale', '1.02');
        updateCursorVars(normX, normY);
      };

      const handlePointerDown = (event) => {
        event.preventDefault();

        if (document.activeElement !== article && typeof article.focus === 'function') {
          article.focus({ preventScroll: true });
        }

        state.pointerId = event.pointerId;
        state.startX = event.clientX;
        state.startY = event.clientY;
        state.isDragging = true;
        state.hasFlipped = false;

        flipEl.setPointerCapture(event.pointerId);
        flipEl.classList.add('is-grabbing');
        flipEl.style.transition = '';
        flipEl.style.setProperty('--tilt-scale', '1');
        updateCursorVars(0, 0);
      };

      const handlePointerMove = (event) => {
        if (state.isDragging) {
          if (state.pointerId !== event.pointerId) {
            return;
          }

          const deltaX = event.clientX - state.startX;
          const deltaY = event.clientY - state.startY;

          if (!state.hasFlipped && Math.abs(deltaX) > 80 && Math.abs(deltaY) < 120) {
            toggleFlip();
            state.hasFlipped = true;
            resetTilt(false);
          } else if (!state.hasFlipped) {
            const dragTilt = clamp(deltaX / 12, -10, 10);
            flipEl.style.setProperty('--tilt-y', `${dragTilt.toFixed(2)}deg`);
          }

          const rect = flipEl.getBoundingClientRect();
          const relativeX = (event.clientX - rect.left) / rect.width;
          const relativeY = (event.clientY - rect.top) / rect.height;
          const normX = clamp((relativeX - 0.5) * 2, -1, 1);
          const normY = clamp((0.5 - relativeY) * 2, -1, 1);
          updateCursorVars(normX, normY);
        } else {
          handleHoverTilt(event);
        }
      };

      const handlePointerEnd = (event) => {
        if (state.pointerId !== event.pointerId) {
          return;
        }

        flipEl.releasePointerCapture(event.pointerId);
        state.pointerId = null;
        state.isDragging = false;
        flipEl.classList.remove('is-grabbing');
        resetTilt();
      };

      flipEl.addEventListener('pointerenter', handleHoverTilt);
      flipEl.addEventListener('pointermove', handlePointerMove);
      flipEl.addEventListener('pointerleave', () => {
        if (state.isDragging) {
          return;
        }
        resetTilt();
      });
      flipEl.addEventListener('pointerdown', handlePointerDown);
      flipEl.addEventListener('pointerup', handlePointerEnd);
      flipEl.addEventListener('pointercancel', handlePointerEnd);

      article.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          toggleFlip();
          resetTilt();
        }
      });

      resetTilt(false);
    }

    // === TAB UI ===
    function setupInfoTabs(root = document) {
      if (!root) {
        return;
      }

      const tabLists = Array.from(root.querySelectorAll('[data-tabs]'));
      if (!tabLists.length) {
        return;
      }

      tabLists.forEach((tabList) => {
        const tabs = Array.from(tabList.querySelectorAll('[role="tab"]'));
        if (!tabs.length) {
          return;
        }

        const escapeSelector = (value = '') => {
          if (typeof CSS !== 'undefined' && typeof CSS.escape === 'function') {
            return CSS.escape(value);
          }
          return String(value).replace(/([ "!#$%&'()*+,./:;<=>?@[\\\]^`{|}~])/g, '\\$1');
        };

        const panels = tabs
          .map((tab) => {
            const panelId = tab.getAttribute('aria-controls');
            return panelId ? root.getElementById(panelId) || root.querySelector(`#${escapeSelector(panelId)}`) : null;
          })
          .filter(Boolean);

        if (!panels.length) {
          return;
        }

        const activateTab = (tab, { setFocus = true } = {}) => {
          if (!tab) {
            return;
          }

          tabs.forEach((btn) => {
            const isActive = btn === tab;
            btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
            btn.classList.toggle('is-active', isActive);
            btn.setAttribute('tabindex', isActive ? '0' : '-1');
          });

          panels.forEach((panel) => {
            const controlsId = tab.getAttribute('aria-controls');
            if (!controlsId || panel.id !== controlsId) {
              panel.hidden = true;
              return;
            }
            panel.hidden = false;
          });

          if (setFocus && typeof tab.focus === 'function') {
            tab.focus({ preventScroll: true });
          }
        };

        const handleKeydown = (event) => {
          const { key } = event;
          const currentIndex = tabs.indexOf(event.currentTarget);
          if (currentIndex === -1) {
            return;
          }

          let nextIndex = null;
          if (key === 'ArrowRight' || key === 'ArrowDown') {
            event.preventDefault();
            nextIndex = (currentIndex + 1) % tabs.length;
          } else if (key === 'ArrowLeft' || key === 'ArrowUp') {
            event.preventDefault();
            nextIndex = (currentIndex + tabs.length - 1) % tabs.length;
          } else if (key === 'Home') {
            event.preventDefault();
            nextIndex = 0;
          } else if (key === 'End') {
            event.preventDefault();
            nextIndex = tabs.length - 1;
          }

          if (nextIndex !== null) {
            activateTab(tabs[nextIndex]);
          }
        };

        tabs.forEach((tab) => {
          tab.addEventListener('click', () => {
            activateTab(tab, { setFocus: false });
          });
          tab.addEventListener('keydown', handleKeydown);
        });

        const initiallySelected = tabs.find((tab) => tab.getAttribute('aria-selected') === 'true') || tabs[0];
        activateTab(initiallySelected, { setFocus: false });
      });
    }

    // === PARTIAL MOUNTING ===
    async function mountCardsSection() {
      const placeholder = cardsSectionMount;
      if (!placeholder) {
        return false;
      }

      const partialName = placeholder.dataset.partial || 'cards';
      const partialUrl = partialName.endsWith('.html') ? partialName : `${partialName}.html`;

      try {
        placeholder.textContent = 'Loading card spotlight‚Ä¶';
        const response = await fetch(partialUrl, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`Failed to load ${partialUrl}: ${response.status}`);
        }

        const markup = (await response.text()).trim();
        if (!markup.length) {
          throw new Error(`Partial ${partialUrl} returned no content`);
        }

        const template = document.createElement('template');
        template.innerHTML = markup;
        const hasGrid = Boolean(template.content.querySelector('#cards-grid'));
        const hasStatus = Boolean(template.content.querySelector('#cards-status'));

        if (!hasGrid || !hasStatus) {
          throw new Error(`Partial ${partialUrl} is missing required nodes`);
        }

        const fragment = template.content.cloneNode(true);
        placeholder.replaceWith(fragment);

        cardsGrid = document.getElementById('cards-grid');
        cardsStatus = document.getElementById('cards-status');

        return Boolean(cardsGrid && cardsStatus);
      } catch (error) {
        console.error('Failed to mount card section', error);
        placeholder.innerHTML = `
          <section class="cards-gallery">
            <div class="container">
              <h2 class="section-title">Card Spotlight</h2>
              <p class="cards-intro">Card previews are unavailable right now.</p>
            </div>
          </section>
        `;
        cardsGrid = null;
        cardsStatus = null;
        return false;
      }
    }

    // === DATA LOADING ===
    async function loadCards() {
      if (!cardsGrid || !cardsStatus) {
        return;
      }

      try {
        cardsStatus.hidden = false;
        cardsStatus.textContent = 'Loading card previews‚Ä¶';

        const response = await fetch('cards/index/by-type.json', { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`Request failed: ${response.status}`);
        }

        const data = await response.json();
        const waifus = Array.isArray(data?.waifu) ? data.waifu : [];
        const orderedWaifus = arrangeTopRowRarities(waifus);

        if (!orderedWaifus.length) {
          cardsStatus.textContent = 'Card previews are coming soon.';
          return;
        }

        cardsStatus.textContent = '';
        cardsStatus.hidden = true;
        cardsGrid.innerHTML = '';

        const fragment = document.createDocumentFragment();
        const interactiveArticles = [];
        const customCardBack = 'assets/images/card-back.png';
        const fallbackCardBack = 'assets/images/card-back-default.svg';

  for (const card of orderedWaifus) {
          const rarityKey = (card.rarity || 'common').toLowerCase();
          const rarityMeta = RARITY_META[rarityKey] || RARITY_META.common;
          const rarityDatasetKey = rarityMeta.datasetKey || rarityMeta.key;
          const rawRarityName = card.rarityName || rarityMeta.name;
          const rawRarityCode = card.rarityCode || rarityMeta.code;
          const rawRaritySymbol = card.raritySymbol || rarityMeta.symbol;
          const rarityName = escapeHtml(rawRarityName);
          const rarityCode = escapeHtml(rawRarityCode);
          const raritySymbol = escapeHtml(rawRaritySymbol);
          const abilityLines = formatSentences(card.text);
          const flavor = card.flavor ? card.flavor.replace(/^‚Äú|‚Äù$/g, '') : '';
          const bondEnergyCount = (() => {
            const bonds = card.bonds;
            if (!bonds) {
              return null;
            }
            const max = parseNumericBondValue(bonds.max);
            if (max !== null) {
              return max;
            }
            const start = parseNumericBondValue(bonds.start);
            if (start !== null) {
              return start;
            }
            return null;
          })();
          const bondCostMap = (() => {
            const thresholds = card.mood?.thresholds;
            if (!thresholds) {
              return {};
            }
            const dereCost = parseNumericBondValue(thresholds.dere);
            const extremeCost = parseNumericBondValue(thresholds.extreme);
            const result = {};
            if (dereCost !== null) {
              result.dere = dereCost;
            }
            if (extremeCost !== null) {
              result.extreme = extremeCost;
            }
            return result;
          })();
          const artDefault = card.art?.default;
          const backArt = card.art?.back || customCardBack;
          const hasArt = Boolean(artDefault);

          const roleRaw = getPrimaryRole(card);
          const roleSlug = roleRaw ? roleRaw.toLowerCase().replace(/[^a-z0-9]+/g, '-') : '';
          const roleLabel = roleRaw ? prettifyLabel(roleRaw) : '';
          const artRole = hasArt ? `${card.name || 'Card'} artwork` : 'Card back artwork';
          const artMarkup = hasArt
            ? `<img src="${artDefault}" alt="">`
            : `<img src="${backArt}" alt="Waifu Wars card back" class="card-art-img-back" onerror="this.onerror=null;this.src='${fallbackCardBack}';">`;

          const cardTitle = escapeHtml(card.name || 'Unnamed Card');
          const speciesSource = [
            card.species,
            card.girlType,
            card.originType,
            card.origin,
            card.subtype,
            card.affinity?.type,
            card.profile?.species,
            card.profile?.origin,
            card.traits?.species,
            card.traits?.origin
          ].find((value) => typeof value === 'string' && value.trim().length);
          const speciesLabel = speciesSource ? prettifyLabel(speciesSource) : 'Unknown';
          const speciesEsc = escapeHtml(speciesLabel);
          const typeLabel = capitalize(card.type || 'waifu');
          const archetypeChip = escapeHtml((card.archetype || typeLabel).toUpperCase());
          const strategyRaw = typeof card.strategy === 'string' ? card.strategy.trim() : '';
          const strategyLabel = strategyRaw ? prettifyLabel(strategyRaw) : (roleLabel || 'Flexible');
          const strategyEsc = escapeHtml(strategyLabel);
          const affectionValue = card.affection ?? '‚Äî';
          const affectionEsc = escapeHtml(String(affectionValue));
          const setLabel = escapeHtml(card.set || 'TBA');
          const idLabel = escapeHtml((card.id || '').toUpperCase());
          const artRoleEsc = escapeHtml(artRole);
          const bondOverlayMarkup = (() => {
            if (!Number.isFinite(bondEnergyCount) || bondEnergyCount <= 0) {
              return '';
            }
            const labelEsc = escapeHtml(`${bondEnergyCount} bond energy`);
            if (bondEnergyCount <= 3) {
              const tokens = Array.from({ length: bondEnergyCount })
                .map(() => '<span class="card-bond-token" aria-hidden="true"></span>')
                .join('');
              return `<div class="card-bond-overlay">${tokens}<span class="sr-only">${labelEsc}</span></div>`;
            }
            const countEsc = escapeHtml(String(bondEnergyCount));
            return `<div class="card-bond-overlay card-bond-overlay--condensed"><span class="card-bond-token" aria-hidden="true"></span><span class="card-bond-count">x${countEsc}</span><span class="sr-only">${labelEsc}</span></div>`;
          })();

          const formattedAbilities = abilityLines
            .map((line) => formatAbilityLine(line, bondCostMap))
            .filter((entry) => entry && typeof entry.html === 'string' && entry.html.trim().length);

          const abilitiesHtml = formattedAbilities.length
            ? formattedAbilities
                .map(({ html, modifier }) => {
                  const attr = (modifier && modifier !== 'plain') ? ` data-ability="${escapeHtml(modifier)}"` : '';
                  return `<li${attr}>${html}</li>`;
                })
                .join('')
            : '<li class="card-ability-empty">Ability text coming soon.</li>';

          const flavorHtml = flavor
            ? `<p class="card-flavor">‚Äú${escapeHtml(flavor)}‚Äù</p>`
            : '';

          const rarityStars = rarityMeta.stars || raritySymbol;
          const rarityStarsHtml = rarityStars
            ? `<span class="card-rarity-stars" aria-hidden="true">${escapeHtml(rarityStars)}</span>`
            : '';
          const ratingEmblem = raritySymbol || rarityCode || '‚òÖ';

          const frontHtml = `
            <div class="card-frame">
              <header class="card-header">
                <span class="card-rarity-badge">
                  <span class="sr-only">${rarityName} rarity</span>
                  <span class="card-rarity-code">${rarityCode}</span>
                </span>
                <div class="card-header-title">
                  ${rarityStarsHtml}
                  <h3 class="card-title">${cardTitle}</h3>
                </div>
                <span class="card-aff-chip">
                  <span class="card-aff-label">AFF</span>
                  <span class="card-aff-value">${affectionEsc}</span>
                </span>
              </header>
              <div class="${hasArt ? 'card-art' : 'card-art card-art--back'}" role="img" aria-label="${artRoleEsc}">
                ${artMarkup}
                <span class="card-chip card-chip--archetype" title="Archetype ${escapeHtml(card.archetype || typeLabel)}">${archetypeChip}</span>
                <span class="card-chip card-chip--strategy" title="Signature effect ${strategyEsc}">${strategyEsc}</span>
                <span class="card-chip card-chip--species" title="Species ${speciesEsc}">${speciesEsc}</span>
              </div>
              <div class="card-text-box">
                ${bondOverlayMarkup}
                <div class="card-text-content">
                  <ul class="card-abilities">
                    ${abilitiesHtml}
                  </ul>
                  ${flavorHtml}
                </div>
              </div>
              <footer class="card-footer" data-rating-symbol="${ratingEmblem}" title="${rarityName} rating">Set ${setLabel} ‚Ä¢ ${idLabel}</footer>
            </div>
          `;

          const backHtml = `
            <div class="card-back-frame" aria-hidden="true">
              <div class="card-back-art">
                <img src="${backArt}" alt="Waifu Wars card back" onerror="this.onerror=null;this.src='${fallbackCardBack}';">
              </div>
            </div>
          `;

          const article = document.createElement('article');
          article.className = 'card-display';
          article.dataset.rarity = rarityDatasetKey;
          article.dataset.rarityTier = rarityMeta.key;
          if (card.archetype) {
            article.dataset.archetype = card.archetype.toLowerCase();
          }
          if (roleLabel) {
            article.dataset.role = roleSlug;
          }
          if (card.id) {
            article.dataset.cardId = card.id;
          }
          if (rarityKey === 'event') {
            article.dataset.rarityVariant = 'event';
          }
          const rarityTheme = (card.rarityTheme || '').toLowerCase();
          if (rarityTheme) {
            article.dataset.rarityTheme = rarityTheme;
          }
          if (card.rarityCode) {
            article.dataset.rarityCode = rawRarityCode;
          }
          if (card.rarityName) {
            article.dataset.rarityName = rawRarityName;
          }
          article.setAttribute('role', 'button');
          article.setAttribute('tabindex', '0');
          article.setAttribute('aria-pressed', 'false');
          article.setAttribute('aria-label', `${card.name || 'Card'} preview. Drag sideways to flip.`);
          article.style.setProperty('--cursor-x', '0');
          article.style.setProperty('--cursor-y', '0');

          article.innerHTML = `
            <div class="card-flip">
              <div class="card-face card-face--front">
                ${frontHtml}
              </div>
              <div class="card-face card-face--back">
                ${backHtml}
              </div>
            </div>
          `;

          fragment.appendChild(article);
          interactiveArticles.push(article);
        }

        cardsGrid.appendChild(fragment);

        balanceAbilityText(cardsGrid);
        fitAllTitles(cardsGrid);
        detectAllOverflow(cardsGrid);

        requestAnimationFrame(() => {
          interactiveArticles.forEach((article) => {
            setupInteractiveCard(article);
          });
        });
      } catch (error) {
        cardsStatus.textContent = 'Could not load cards right now. Try refreshing in a moment.';
        cardsStatus.hidden = false;
        console.error(error);
      }
    }

    // === LIFECYCLE ===
    window.addEventListener('resize', () => {
      const scope = cardsGrid || document;
      balanceAbilityText(scope);
      fitAllTitles(scope);
      detectAllOverflow(scope);
    });

    if (document.fonts && typeof document.fonts.ready?.then === 'function') {
      document.fonts.ready.then(() => {
        const scope = cardsGrid || document;
        balanceAbilityText(scope);
        fitAllTitles(scope);
        detectAllOverflow(scope);
      }).catch(() => {});
    }

    const initPage = async () => {
      setupInfoTabs();
      const mounted = await mountCardsSection();
      if (mounted) {
        await loadCards();
      }
    };

    initPage().catch((error) => {
      console.error('Waifu Wars init failed', error);
    });
  </script>
</body>
</html>
