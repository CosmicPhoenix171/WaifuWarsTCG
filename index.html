<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Waifu Wars TCG ‚Äì Emotional Strategy Card Game</title>
  <meta name="description" content="Waifu Wars TCG: fast tactical anime card game where Bonds, moods, and archetypes forge dramatic comebacks." />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#ee2e8b" />
  <meta property="og:title" content="Waifu Wars TCG" />
  <meta property="og:description" content="Tactical anime card battler with bonds, mood states, and archetype matchups." />
  <meta property="og:type" content="website" />
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%236d5dfc'/%3E%3Cpath d='M20 38c6 6 12 6 18 0 5-5 5-13 0-18-4-4-10-4-14 0-5 5-5 13 0 18z' fill='%23fff'/%3E%3C/svg%3E" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>
  <header class="site-header">
    <div class="container nav">
      <div class="brand">
        <span class="logo">Waifu Wars</span>
        <span class="tag">TCG</span>
      </div>
      <nav class="menu" aria-label="Primary">
        <a href="#battle-loop">Battle Loop</a>
        <a href="#emotional-engine">Emotional Engine</a>
        <a href="#features">Features</a>
        <a href="#join">Join</a>
      </nav>
    </div>
  </header>

  <main id="main">
    <section class="hero">
      <div class="container hero-inner">
        <div class="hero-copy">
          <h1 class="title">Outplay With Emotion</h1>
          <p class="subtitle">A tactical anime card battler where Bonds, mood swings, and archetype matchups decide every duel.</p>
          <div class="cta-row">
            <a class="btn btn-primary" href="#battle-loop">Learn How To Play</a>
            <a class="btn btn-ghost" href="#features">See Features</a>
          </div>
          <div class="hero-highlights">
            <div class="chip">Bonds-powered abilities</div>
            <div class="chip">Neutral ‚Üí Dere ‚Üí Extreme</div>
            <div class="chip">Passion ‚Ä¢ Stoic ‚Ä¢ Heart</div>
          </div>
        </div>
        <div class="hero-art" aria-hidden="true">
          <div class="card-mock one"></div>
          <div class="card-mock two"></div>
          <div class="card-mock three"></div>
        </div>
      </div>
    </section>

    <section id="battle-loop" class="battle-loop">
      <div class="container">
        <h2 class="section-title">Battle Loop Snapshot</h2>
        <ol class="loop">
          <li><strong>Draw Phase:</strong> Draw 1 card; fire start-of-turn triggers.</li>
          <li><strong>Main Phase:</strong> Summon up to 3 waifus, play Support, set Traps.</li>
          <li><strong>Battle Phase:</strong> Declare attacks; Affection damage & bond checks.</li>
          <li><strong>End Phase:</strong> Resolve lingering effects, update Bonds & mood.</li>
        </ol>
        <p class="round-note">Round ends if you lose three waifus or finish with none in play. Simultaneous knockout? Narrative privilege awards you the win.</p>
      </div>
    </section>

    <section id="emotional-engine" class="engine">
      <div class="container">
        <h2 class="section-title">Emotional Engine</h2>
        <div class="engine-grid">
          <div class="engine-card">
            <h3>Affection (HP)</h3>
            <p>Each waifu‚Äôs durability. Drop to 0 and she exits‚Äîunless a Final Stand bends fate.</p>
          </div>
          <div class="engine-card">
            <h3>Bonds</h3>
            <p>Relationship meter fueling Confessions, meltdowns, and clutch survival effects.</p>
          </div>
          <div class="engine-card">
            <h3>Mood States</h3>
            <p>Neutral ‚Üí Dere ‚Üí Extreme escalations unlock power spikes & alternate art moments.</p>
          </div>
          <div class="engine-card">
            <h3>Bond Cards</h3>
            <p>Create Lover / Rival / Mentor links for shared triggers and combo supers.</p>
          </div>
        </div>
      </div>
    </section>

    <section id="features" class="features">
      <div class="container">
        <h2 class="section-title">What Makes It Different</h2>
        <div class="grid">
          <article class="feature">
            <h3>Emotion-Driven Combat</h3>
            <p>Build Bonds, trigger Confessions, and pivot moods to flip the battlefield in your favor.</p>
          </article>
          <article class="feature">
            <h3>Clear Archetypes</h3>
            <p>Tsundere strikes, Kuudere control, Yandere deletion‚Äîdistinct playstyles that stay balanced.</p>
          </article>
          <article class="feature">
            <h3>Collect ‚Ä¢ Trade ‚Ä¢ Flex</h3>
            <p>Open packs with animated reveals, complete sets, and trade safely in the hub.</p>
          </article>
          <article class="feature">
            <h3>Made for Web & Mobile</h3>
            <p>Responsive UI, touch-friendly layouts, and readable typography out of the box.</p>
          </article>
        </div>
      </div>
    </section>

    <section id="lore-index" class="info-section">
      <div class="container">
        <h2 class="section-title">Know Your Lineup</h2>
        <p class="info-intro">Plan team synergy at a glance. Each chart highlights the species roster, core combat effects, and the dere personalities powering your bond plays.</p>
        <div class="info-tabs" role="tablist" aria-label="Lore Index Tabs" data-tabs>
          <button type="button" class="info-tab is-active" id="tab-species" role="tab" aria-selected="true" aria-controls="species-panel" data-tab-target="species-panel">Species Lineup</button>
          <button type="button" class="info-tab" id="tab-effects" role="tab" aria-selected="false" aria-controls="effects-panel" data-tab-target="effects-panel" tabindex="-1">Effect Types</button>
          <button type="button" class="info-tab" id="tab-dere" role="tab" aria-selected="false" aria-controls="dere-panel" data-tab-target="dere-panel" tabindex="-1">Dere Archetypes</button>
        </div>
        <div class="info-panels">
          <section class="info-panel" role="tabpanel" id="species-panel" aria-labelledby="tab-species">
            <h3>Species Lineup</h3>
            <p class="info-panel-copy">Every species leans into a unique combat fantasy‚Äîmix and match to balance raw power, control, and narrative flair.</p>
            <div class="table-scroll" role="group" aria-labelledby="species-table-caption">
              <table class="info-table" id="species-table">
                <caption id="species-table-caption" class="sr-only">Species options and their core descriptions</caption>
                <thead>
                  <tr>
                    <th scope="col">Species</th>
                    <th scope="col">Description</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th scope="row">Human</th>
                    <td>Baseline; no inherent bonus or penalty.</td>
                  </tr>
                  <tr>
                    <th scope="row">Elf</th>
                    <td>Nature-linked, wise and graceful.</td>
                  </tr>
                  <tr>
                    <th scope="row">Kitsune</th>
                    <td>Illusionist tricksters; clever and seductive.</td>
                  </tr>
                  <tr>
                    <th scope="row">Demon</th>
                    <td>Dark power users; chaotic but strong.</td>
                  </tr>
                  <tr>
                    <th scope="row">Angel</th>
                    <td>Holy beings of purity and protection.</td>
                  </tr>
                  <tr>
                    <th scope="row">Vampire</th>
                    <td>Life-draining predators; elegant yet tragic.</td>
                  </tr>
                  <tr>
                    <th scope="row">Android</th>
                    <td>Artificial waifus; logical and emotion-learning.</td>
                  </tr>
                  <tr>
                    <th scope="row">Slime</th>
                    <td>Adaptive and underestimated shapeshifters.</td>
                  </tr>
                  <tr>
                    <th scope="row">Succubus</th>
                    <td>Seductive energy manipulators.</td>
                  </tr>
                  <tr>
                    <th scope="row">Neko (Catgirl)</th>
                    <td>Playful, mischievous, cute but dangerous.</td>
                  </tr>
                  <tr>
                    <th scope="row">Dragonkin</th>
                    <td>Proud, powerful, ancient bloodline.</td>
                  </tr>
                  <tr>
                    <th scope="row">Fairy</th>
                    <td>Magical and supportive; small but potent.</td>
                  </tr>
                  <tr>
                    <th scope="row">Mermaid</th>
                    <td>Songstress of the sea, gentle healer type.</td>
                  </tr>
                  <tr>
                    <th scope="row">Ghost</th>
                    <td>Ethereal beings tied to emotion.</td>
                  </tr>
                  <tr>
                    <th scope="row">Witch</th>
                    <td>Spellcasters with knowledge-based magic.</td>
                  </tr>
                  <tr>
                    <th scope="row">Idol</th>
                    <td>Performers powered by admiration and fame.</td>
                  </tr>
                  <tr>
                    <th scope="row">Goddess</th>
                    <td>Divine entities with immense but costly power.</td>
                  </tr>
                  <tr>
                    <th scope="row">Alien</th>
                    <td>Mysterious off-world beings with random effects.</td>
                  </tr>
                  <tr>
                    <th scope="row">Zombie</th>
                    <td>Cute corpses with resistance to debuffs.</td>
                  </tr>
                  <tr>
                    <th scope="row">Magical Girl</th>
                    <td>Hopeful heroes of light and friendship.</td>
                  </tr>
                  <tr>
                    <th scope="row">Hybrid</th>
                    <td>Combines two species traits with mixed bonuses.</td>
                  </tr>
                  <tr>
                    <th scope="row">Deity</th>
                    <td>Godlike form with unique dual effects (event/ultra rare).</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section class="info-panel" role="tabpanel" id="effects-panel" aria-labelledby="tab-effects" hidden>
            <h3>Effect Types</h3>
            <p class="info-panel-copy">These keywords frame most card text‚Äîstack combos that layer damage, disruption, and protection.</p>
            <div class="table-scroll" role="group" aria-labelledby="effects-table-caption">
              <table class="info-table" id="effects-table">
                <caption id="effects-table-caption" class="sr-only">Effect keywords with their core functions</caption>
                <thead>
                  <tr>
                    <th scope="col">Effect Type</th>
                    <th scope="col">Core Function</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th scope="row">Burn üî•</th>
                    <td>Deals damage over time.</td>
                  </tr>
                  <tr>
                    <th scope="row">Poison ‚ò†Ô∏è</th>
                    <td>Ignores defenses; damages each turn.</td>
                  </tr>
                  <tr>
                    <th scope="row">Heal üíö</th>
                    <td>Restores Affection to allies.</td>
                  </tr>
                  <tr>
                    <th scope="row">Charm üíò</th>
                    <td>Disables, converts, or distracts an enemy.</td>
                  </tr>
                  <tr>
                    <th scope="row">Shield üõ°Ô∏è</th>
                    <td>Blocks or reduces incoming damage.</td>
                  </tr>
                  <tr>
                    <th scope="row">Drain ü©∏</th>
                    <td>Steals AFF (HP) or BP from target.</td>
                  </tr>
                  <tr>
                    <th scope="row">Freeze ‚ùÑÔ∏è</th>
                    <td>Prevents enemy action for one turn.</td>
                  </tr>
                  <tr>
                    <th scope="row">Boost ‚ö°</th>
                    <td>Raises Bond or Affection temporarily.</td>
                  </tr>
                  <tr>
                    <th scope="row">Curse üïØÔ∏è</th>
                    <td>Reduces enemy power or healing.</td>
                  </tr>
                  <tr>
                    <th scope="row">Resurrect üåô</th>
                    <td>Revives a defeated ally.</td>
                  </tr>
                  <tr>
                    <th scope="row">Copy üåÄ</th>
                    <td>Copies another card‚Äôs ability.</td>
                  </tr>
                  <tr>
                    <th scope="row">Pierce üí¢</th>
                    <td>Ignores shields or defense.</td>
                  </tr>
                  <tr>
                    <th scope="row">Cleanse üíß</th>
                    <td>Removes debuffs or negative effects.</td>
                  </tr>
                  <tr>
                    <th scope="row">Silence üîá</th>
                    <td>Blocks an enemy‚Äôs ability activation.</td>
                  </tr>
                  <tr>
                    <th scope="row">Summon ‚ú®</th>
                    <td>Calls a Support or temporary clone.</td>
                  </tr>
                  <tr>
                    <th scope="row">Steal üíé</th>
                    <td>Takes BP or buffs from enemy.</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section class="info-panel" role="tabpanel" id="dere-panel" aria-labelledby="tab-dere" hidden>
            <h3>Dere Archetypes</h3>
            <p class="info-panel-copy">Personality drives tactics‚Äîdraft dere types that reinforce your win condition.</p>
            <div class="table-scroll" role="group" aria-labelledby="dere-table-caption">
              <table class="info-table" id="dere-table">
                <caption id="dere-table-caption" class="sr-only">Dere archetypes with symbols, battle traits, and synergies</caption>
                <thead>
                  <tr>
                    <th scope="col">Dere Type</th>
                    <th scope="col">Symbol</th>
                    <th scope="col">Personality Summary</th>
                    <th scope="col">Core Trait in Battle</th>
                    <th scope="col">Ability Synergy</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th scope="row">Tsundere</th>
                    <td>üî•</td>
                    <td>Acts hostile or embarrassed to hide affection.</td>
                    <td>Prideful offense, emotional defense.</td>
                    <td>Burn, Boost, Shield</td>
                  </tr>
                  <tr>
                    <th scope="row">Yandere</th>
                    <td>üíî</td>
                    <td>Deeply obsessed, jealous, violent if love is threatened.</td>
                    <td>Sacrifices Affection for power.</td>
                    <td>Drain, Curse, Charm</td>
                  </tr>
                  <tr>
                    <th scope="row">Kuudere</th>
                    <td>‚ùÑÔ∏è</td>
                    <td>Cold and calm, shows warmth privately.</td>
                    <td>Consistent, unshakable control.</td>
                    <td>Freeze, Shield, Pierce</td>
                  </tr>
                  <tr>
                    <th scope="row">Dandere</th>
                    <td>üå∏</td>
                    <td>Shy, soft-spoken, loyal and patient.</td>
                    <td>Healer and quiet support.</td>
                    <td>Heal, Boost, Cleanse</td>
                  </tr>
                  <tr>
                    <th scope="row">Deredere</th>
                    <td>üíï</td>
                    <td>Cheerful, affectionate, pure-hearted optimist.</td>
                    <td>Buffs allies through love.</td>
                    <td>Boost, Heal, Charm</td>
                  </tr>
                  <tr>
                    <th scope="row">Himedere</th>
                    <td>üëë</td>
                    <td>Regal, demands admiration and loyalty.</td>
                    <td>Leader archetype; commands others.</td>
                    <td>Shield, Charm, Pierce</td>
                  </tr>
                  <tr>
                    <th scope="row">Kamidere</th>
                    <td>‚ú®</td>
                    <td>God-complex, absolute authority, power-driven.</td>
                    <td>Massive BP spikes; risks backfire.</td>
                    <td>Curse, Burn, Boost</td>
                  </tr>
                  <tr>
                    <th scope="row">Utsudere</th>
                    <td>üïØÔ∏è</td>
                    <td>Depressed, gloomy, emotionally fragile.</td>
                    <td>Self-damaging but strong healing synergy.</td>
                    <td>Drain, Heal, Curse</td>
                  </tr>
                  <tr>
                    <th scope="row">Bakadere</th>
                    <td>ü´∂</td>
                    <td>Clumsy, airheaded, sweetly naive.</td>
                    <td>Random BP surges; unpredictable.</td>
                    <td>Boost, Heal, Charm</td>
                  </tr>
                  <tr>
                    <th scope="row">Mayadere</th>
                    <td>üï∏Ô∏è</td>
                    <td>Villainess who turns good after bonding.</td>
                    <td>Strong early offense, late support.</td>
                    <td>Drain, Boost, Heal</td>
                  </tr>
                  <tr>
                    <th scope="row">Darudere</th>
                    <td>üò¥</td>
                    <td>Lazy, chill, easygoing.</td>
                    <td>Low BP gain, immune to stress effects.</td>
                    <td>Shield, Heal, Copy</td>
                  </tr>
                  <tr>
                    <th scope="row">Yangire</th>
                    <td>üíÄ</td>
                    <td>Violent like Yandere but without love focus.</td>
                    <td>Raw chaos power.</td>
                    <td>Burn, Curse, Drain</td>
                  </tr>
                  <tr>
                    <th scope="row">Hinedere</th>
                    <td>‚ö´</td>
                    <td>Cynical, rude, hides caring side.</td>
                    <td>Reduces opponent BP efficiency.</td>
                    <td>Pierce, Burn, Curse</td>
                  </tr>
                  <tr>
                    <th scope="row">Oujoudere</th>
                    <td>üëí</td>
                    <td>Elegant, well-mannered noble type.</td>
                    <td>Improves ally synergy; stable buff source.</td>
                    <td>Boost, Shield, Heal</td>
                  </tr>
                  <tr>
                    <th scope="row">Nyandere</th>
                    <td>üêæ</td>
                    <td>Catlike personality ‚Äî playful, affectionate but moody.</td>
                    <td>Gains BP randomly; risk/reward playstyle.</td>
                    <td>Charm, Boost, Burn</td>
                  </tr>
                  <tr>
                    <th scope="row">Shundere</th>
                    <td>üåßÔ∏è</td>
                    <td>Sad, withdrawn, pessimistic, but kind-hearted.</td>
                    <td>Emotional support, regenerates BP slowly.</td>
                    <td>Heal, Drain, Curse</td>
                  </tr>
                  <tr>
                    <th scope="row">Kekkondere</th>
                    <td>üíç</td>
                    <td>Desperately wants marriage or long-term bond.</td>
                    <td>Bond-based power multiplier.</td>
                    <td>Boost, Charm, Drain</td>
                  </tr>
                  <tr>
                    <th scope="row">Nemuidere</th>
                    <td>üò¥üí§</td>
                    <td>Sleepy, peaceful, carefree waifu.</td>
                    <td>Starts with low BP but regenerates passively.</td>
                    <td>Heal, Shield, Boost</td>
                  </tr>
                  <tr>
                    <th scope="row">Byoukidere</th>
                    <td>üíä</td>
                    <td>Ill or fragile health, endures through pain.</td>
                    <td>Gains BP when taking damage.</td>
                    <td>Heal, Drain, Boost</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </div>
      </div>
    </section>

    <section id="cards" class="cards-gallery">
      <div class="container">
        <h2 class="section-title">Card Spotlight</h2>
        <p class="cards-intro">Preview a sampling of Waifu archetypes‚Äîeach colorful personality brings unique stats, moods, and tags to weave into your bond-driven strategy.</p>
        <div id="cards-status" class="cards-status" role="status" aria-live="polite">Loading card previews‚Ä¶</div>
        <div id="cards-grid" class="cards-grid" aria-live="polite"></div>
      </div>
    </section>

    <section class="callouts">
      <div class="container">
        <div class="callout">
          <div class="callout-copy">
            <h3>Meet the Archetypes</h3>
            <p>Learn the macro families‚ÄîPassion Surge, Stoic Control, Heart Guard‚Äîand how they create soft matchups.</p>
            <a class="btn btn-secondary" href="#features">Explore Archetypes</a>
          </div>
        </div>
        <div class="callout alt">
          <div class="callout-copy">
            <h3>Build Your First Deck</h3>
            <p>Start with a Tsundere reactive shell or a Deredere support core‚Äîsimple rules, deep strategy.</p>
            <a class="btn btn-secondary" href="#cards">See Cards</a>
          </div>
        </div>
      </div>
    </section>

    <section id="join" class="cta">
      <div class="container">
        <h2 class="section-title">Join The Journey</h2>
        <p>Follow development and get notified when the alpha opens.</p>
        <div class="cta-row">
          <a class="btn btn-primary" href="#">Join Waitlist</a>
          <a class="btn btn-ghost" href="#features">Learn More</a>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <div>¬© <span id="year"></span> Waifu Wars TCG</div>
      <div class="footer-links">
        <a href="#join">Contact</a>
        <a href="https://github.com/CosmicPhoenix171/WaifuWarsTCG" target="_blank" rel="noopener">GitHub</a>
      </div>
    </div>
  </footer>

  <script type="module">
    // === DOM REFERENCES ===
    const yearEl = document.getElementById('year');
    const cardsGrid = document.getElementById('cards-grid');
    const cardsStatus = document.getElementById('cards-status');

    if (yearEl) {
      yearEl.textContent = new Date().getFullYear();
    }

    // === CONFIGURATION ===
  const RARITY_META = {
      common: {
        key: 'common',
        datasetKey: 'common',
        name: 'Common',
        code: 'C',
        symbol: '‚óè',
        stars: '‚Ä¢'
      },
      rare: {
        key: 'rare',
        datasetKey: 'rare',
        name: 'Rare',
        code: 'R',
        symbol: '‚òÖ',
        stars: '‚òÖ'
      },
      'super-rare': {
        key: 'super-rare',
        datasetKey: 'super-rare',
        name: 'Super Rare',
        code: 'SR',
        symbol: '‚òÖ‚òÖ',
        stars: '‚òÖ‚òÖ'
      },
      'special-super-rare': {
        key: 'special-super-rare',
        datasetKey: 'special-super-rare',
        name: 'Special Super Rare',
        code: 'SSR',
        symbol: '‚òÖ‚òÖ‚òÖ',
        stars: '‚òÖ‚òÖ‚òÖ'
      },
      ultra: {
        key: 'ultra',
        datasetKey: 'ultra',
        name: 'Ultra Rare',
        code: 'UR',
        symbol: '‚ú™',
        stars: '‚ú™'
      },
      event: {
        key: 'event',
        datasetKey: 'ultra',
        name: 'Event Exclusive',
        code: 'EX',
        symbol: '‚ú™',
        stars: '‚ú™'
      }
    };

    // === UTILITY HELPERS ===
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function escapeHtml(str = '') {
      return String(str).replace(/[&<>"']/g, (ch) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[ch]));
    }

    function capitalize(word = '') {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }

    function formatSentences(text) {
      if (!text) {
        return [];
      }
      return String(text)
        .split(/(?:\r?\n|\r)+|(?<=[.!?])\s+/)
        .map((line) => line.trim())
        .filter(Boolean);
    }

    function formatBonds(bonds) {
      if (!bonds) {
        return '‚Äî';
      }
      const start = typeof bonds.start === 'number' ? bonds.start : null;
      const max = typeof bonds.max === 'number' ? bonds.max : null;
      if (start !== null && max !== null) {
        return `${start} / ${max}`;
      }
      if (max !== null) {
        return `${max}`;
      }
      return '‚Äî';
    }

    function formatMood(mood) {
      if (!mood) {
        return '‚Äî / ‚Äî';
      }
      const dere = mood.dere ?? '‚Äî';
      const extreme = mood.extreme ?? '‚Äî';
      return `${dere} / ${extreme}`;
    }

    function prettifyLabel(value = '') {
      return value
        .toString()
        .replace(/[_-]+/g, ' ')
        .replace(/\b\w/g, (ch) => ch.toUpperCase())
        .trim();
    }

    function getPrimaryRole(card = {}) {
      if (!card) {
        return '';
      }
      if (card.role) {
        return card.role;
      }
      if (typeof card.strategy === 'string' && card.strategy.trim().length) {
        return card.strategy;
      }
      return '';
    }

    function decorateAbilityText(text = '') {
      let output = escapeHtml(text);
      const replacements = [
        { pattern: /\{?BOND\}?/gi, markup: '<span class="card-icon card-icon--bond" aria-hidden="true"></span><span class="sr-only">Bond</span>' },
        { pattern: /\bATK\b/g, markup: '<span class="card-icon card-icon--atk" aria-hidden="true"></span><span class="sr-only">Attack</span>' },
        { pattern: /\bDEF\b/g, markup: '<span class="card-icon card-icon--def" aria-hidden="true"></span><span class="sr-only">Defense</span>' },
        { pattern: /\bHP\b/gi, markup: '<span class="card-icon card-icon--hp" aria-hidden="true"></span><span class="sr-only">Health</span>' },
        { pattern: /\bAFFECTION\b/gi, markup: '<span class="card-icon card-icon--aff" aria-hidden="true"></span><span class="sr-only">Affection</span>' }
      ];
      replacements.forEach(({ pattern, markup }) => {
        output = output.replace(pattern, markup);
      });
      return output;
    }

    function formatAbilityLine(line = '') {
      const trimmed = line.trim();
      if (!trimmed) {
        return '';
      }
      const keywordMatch = trimmed.match(/^([^:\u2014\u2013\-]{1,48}?)[\s]*(?:[:\u2014\u2013\-])\s+(.+)$/u);
      if (keywordMatch) {
        const keyword = decorateAbilityText(keywordMatch[1]);
        const body = decorateAbilityText(keywordMatch[2]);
        return `<span class="card-ability-keyword">${keyword}<span aria-hidden="true"> ‚Äî</span></span><span class="card-ability-body">${body}</span>`;
      }
      return `<span class="card-ability-body">${decorateAbilityText(trimmed)}</span>`;
    }

    // === LAYOUT HELPERS ===
    function balanceAbilityText(root = document) {
      if (!root || typeof root.querySelectorAll !== 'function') return;
      root.querySelectorAll('.card-text-box').forEach((textBox) => {
        if (textBox.dataset.fluid === 'true') return; // skip auto-fit for fluid boxes
        const abilities = textBox.querySelector('.card-abilities');
        if (!abilities) return;

        // Reset any previous inline tweaks
        abilities.style.fontSize = '';
        abilities.style.lineHeight = '';
        abilities.style.gap = '';
        const flavorEl = textBox.querySelector('.card-flavor');
        if (flavorEl) flavorEl.style.display = '';

        const cs = getComputedStyle(abilities);
        let fontSize = parseFloat(cs.fontSize) || 14;
        let lineHeight = parseFloat(cs.lineHeight) || Math.max(1.2, (fontSize * 1.35));
        let gap = parseFloat((cs.gap || '0').toString()) || 7.2; // approx .45rem

  const minFont = 8.5;
  const minLine = Math.max(1.02, fontSize * 1.12);
  const minGap = 1; // px

        // Helper to check overflow
        const overflows = () => textBox.scrollHeight > textBox.clientHeight + 1;

        // Step 1: shrink font size
        while (overflows() && fontSize > minFont) {
          fontSize -= 0.5;
          abilities.style.fontSize = `${fontSize}px`;
        }

        // Step 2: tighten line-height
        // Re-read lineHeight in px for consistency
        lineHeight = parseFloat(getComputedStyle(abilities).lineHeight) || lineHeight;
        while (overflows() && lineHeight > minLine) {
          lineHeight -= 0.5;
          abilities.style.lineHeight = `${lineHeight}px`;
        }

        // Step 3: reduce gap between ability items
        gap = parseFloat(getComputedStyle(abilities).gap) || gap;
        while (overflows() && gap > minGap) {
          gap -= 1;
          abilities.style.gap = `${gap}px`;
        }

        // Step 4: hide flavor text as last resort
        if (overflows() && flavorEl) {
          flavorEl.style.display = 'none';
        }

        // Final pass: tiny font bump down if still overflowing
        let guard = 10;
        while (overflows() && guard--) {
          fontSize -= 0.25;
          abilities.style.fontSize = `${Math.max(minFont - 1.5, fontSize)}px`;
        }
      });
    }

    function fitCardTitle(titleEl) {
      if (!titleEl) return;
      // Preserve original inline values we touch
      const original = {
        display: titleEl.style.display,
        webkitLineClamp: titleEl.style.webkitLineClamp,
        lineClamp: titleEl.style.lineClamp,
        webkitBoxOrient: titleEl.style.webkitBoxOrient,
        overflow: titleEl.style.overflow,
        fontSize: titleEl.style.fontSize
      };

      const computed = getComputedStyle(titleEl);
      let fontSize = parseFloat(computed.fontSize) || 18;
      const minFont = 12; // don't go too tiny

      // Temporarily remove clamp to measure full height
      titleEl.style.display = 'block';
      titleEl.style.webkitLineClamp = 'unset';
      titleEl.style.lineClamp = 'unset';
      titleEl.style.webkitBoxOrient = 'unset';
      titleEl.style.overflow = 'visible';

      // Compute allowed height for two lines
      const lhPx = (() => {
        const lh = computed.lineHeight;
        const num = parseFloat(lh);
        if (lh.endsWith('px')) return num;
        // fallback: scale of font size
        return (parseFloat(computed.fontSize) || 18) * 1.3;
      })();
      const allowed = lhPx * 2.05; // slightly generous

      // Reduce font until fits within 2 lines
      while (titleEl.scrollHeight > allowed && fontSize > minFont) {
        fontSize -= 0.5;
        titleEl.style.fontSize = `${fontSize}px`;
      }

      // Restore clamp behavior
      titleEl.style.display = original.display || '-webkit-box';
      titleEl.style.webkitLineClamp = original.webkitLineClamp || '2';
      titleEl.style.lineClamp = original.lineClamp || '2';
      titleEl.style.webkitBoxOrient = original.webkitBoxOrient || 'vertical';
      titleEl.style.overflow = original.overflow || 'hidden';
      // Keep the adjusted fontSize
    }

    function fitAllTitles(root = document) {
      const titles = root.querySelectorAll('.card-title');
      titles.forEach(fitCardTitle);
    }
    // === OVERFLOW DETECTION ===
    function titleWouldOverflow(titleEl) {
      if (!titleEl) return false;
      const prev = {
        display: titleEl.style.display,
        webkitLineClamp: titleEl.style.webkitLineClamp,
        lineClamp: titleEl.style.lineClamp,
        webkitBoxOrient: titleEl.style.webkitBoxOrient,
        overflow: titleEl.style.overflow
      };
      const computed = getComputedStyle(titleEl);
      // Temporarily remove clamp & overflow to measure full height
      titleEl.style.display = 'block';
      titleEl.style.webkitLineClamp = 'unset';
      titleEl.style.lineClamp = 'unset';
      titleEl.style.webkitBoxOrient = 'unset';
      titleEl.style.overflow = 'visible';
      const lhPx = (() => {
        const lh = computed.lineHeight;
        const num = parseFloat(lh);
        if (lh.endsWith('px')) return num;
        return (parseFloat(computed.fontSize) || 18) * 1.3;
      })();
      const allowed = lhPx * 2.05;
      const wouldOverflow = titleEl.scrollHeight > allowed + 0.5;
      // restore
      titleEl.style.display = prev.display || '-webkit-box';
      titleEl.style.webkitLineClamp = prev.webkitLineClamp || '2';
      titleEl.style.lineClamp = prev.lineClamp || '2';
      titleEl.style.webkitBoxOrient = prev.webkitBoxOrient || 'vertical';
      titleEl.style.overflow = prev.overflow || 'hidden';
      return wouldOverflow;
    }

    function detectCardOverflow(article) {
      if (!article) return;
      const textBox = article.querySelector('.card-text-box');
      const title = article.querySelector('.card-title');
      let overflow = false;
      if (textBox) {
        overflow = overflow || (textBox.scrollHeight > textBox.clientHeight + 1);
      }
      if (title) {
        overflow = overflow || titleWouldOverflow(title);
      }
      if (overflow) {
        article.dataset.overflow = 'true';
      } else {
        delete article.dataset.overflow;
      }
    }

    function detectAllOverflow(root = document) {
      const cards = root.querySelectorAll('.card-display');
      cards.forEach(detectCardOverflow);
    }

    // === INTERACTION ===
    function setupInteractiveCard(article) {
      const flipEl = article.querySelector('.card-flip');
      if (!flipEl) {
        return;
      }

      const state = {
        pointerId: null,
        startX: 0,
        startY: 0,
        isDragging: false,
        hasFlipped: false,
        isFlipped: flipEl.classList.contains('is-flipped'),
        resetTimer: null
      };

      article.setAttribute('aria-pressed', state.isFlipped ? 'true' : 'false');

      const maxTiltX = 10;
      const maxTiltY = 16;

      const updateCursorVars = (nx = 0, ny = 0) => {
        article.style.setProperty('--cursor-x', Number.isFinite(nx) ? nx.toFixed(3) : '0');
        article.style.setProperty('--cursor-y', Number.isFinite(ny) ? ny.toFixed(3) : '0');
      };
      updateCursorVars(0, 0);

      const resetTilt = (smooth = true) => {
        if (state.resetTimer) {
          clearTimeout(state.resetTimer);
          state.resetTimer = null;
        }

        if (smooth) {
          flipEl.style.transition = 'transform .26s ease, box-shadow .26s ease';
          flipEl.style.setProperty('--tilt-x', '0deg');
          flipEl.style.setProperty('--tilt-y', '0deg');
          flipEl.style.setProperty('--tilt-scale', '1');
          state.resetTimer = setTimeout(() => {
            flipEl.style.transition = '';
            state.resetTimer = null;
          }, 260);
        } else {
          flipEl.style.transition = '';
          flipEl.style.setProperty('--tilt-x', '0deg');
          flipEl.style.setProperty('--tilt-y', '0deg');
          flipEl.style.setProperty('--tilt-scale', '1');
        }

        updateCursorVars(0, 0);
      };

      const toggleFlip = () => {
        state.isFlipped = !state.isFlipped;
        flipEl.classList.toggle('is-flipped', state.isFlipped);
        article.setAttribute('aria-pressed', state.isFlipped ? 'true' : 'false');
      };

      const handleHoverTilt = (event) => {
        if (state.isDragging) {
          return;
        }

        const rect = flipEl.getBoundingClientRect();
        const relativeX = (event.clientX - rect.left) / rect.width;
        const relativeY = (event.clientY - rect.top) / rect.height;
        const tiltY = clamp((relativeX - 0.5) * 2 * maxTiltY, -maxTiltY, maxTiltY);
        const tiltX = clamp((0.5 - relativeY) * 2 * maxTiltX, -maxTiltX, maxTiltX);
        const normX = clamp((relativeX - 0.5) * 2, -1, 1);
        const normY = clamp((0.5 - relativeY) * 2, -1, 1);

        flipEl.style.setProperty('--tilt-x', `${tiltX.toFixed(2)}deg`);
        flipEl.style.setProperty('--tilt-y', `${tiltY.toFixed(2)}deg`);
        flipEl.style.setProperty('--tilt-scale', '1.02');
        updateCursorVars(normX, normY);
      };

      const handlePointerDown = (event) => {
        event.preventDefault();

        if (document.activeElement !== article && typeof article.focus === 'function') {
          article.focus({ preventScroll: true });
        }

        state.pointerId = event.pointerId;
        state.startX = event.clientX;
        state.startY = event.clientY;
        state.isDragging = true;
        state.hasFlipped = false;

        flipEl.setPointerCapture(event.pointerId);
        flipEl.classList.add('is-grabbing');
        flipEl.style.transition = '';
        flipEl.style.setProperty('--tilt-scale', '1');
        updateCursorVars(0, 0);
      };

      const handlePointerMove = (event) => {
        if (state.isDragging) {
          if (state.pointerId !== event.pointerId) {
            return;
          }

          const deltaX = event.clientX - state.startX;
          const deltaY = event.clientY - state.startY;

          if (!state.hasFlipped && Math.abs(deltaX) > 80 && Math.abs(deltaY) < 120) {
            toggleFlip();
            state.hasFlipped = true;
            resetTilt(false);
          } else if (!state.hasFlipped) {
            const dragTilt = clamp(deltaX / 12, -10, 10);
            flipEl.style.setProperty('--tilt-y', `${dragTilt.toFixed(2)}deg`);
          }

          const rect = flipEl.getBoundingClientRect();
          const relativeX = (event.clientX - rect.left) / rect.width;
          const relativeY = (event.clientY - rect.top) / rect.height;
          const normX = clamp((relativeX - 0.5) * 2, -1, 1);
          const normY = clamp((0.5 - relativeY) * 2, -1, 1);
          updateCursorVars(normX, normY);
        } else {
          handleHoverTilt(event);
        }
      };

      const handlePointerEnd = (event) => {
        if (state.pointerId !== event.pointerId) {
          return;
        }

        flipEl.releasePointerCapture(event.pointerId);
        state.pointerId = null;
        state.isDragging = false;
        flipEl.classList.remove('is-grabbing');
        resetTilt();
      };

      flipEl.addEventListener('pointerenter', handleHoverTilt);
      flipEl.addEventListener('pointermove', handlePointerMove);
      flipEl.addEventListener('pointerleave', () => {
        if (state.isDragging) {
          return;
        }
        resetTilt();
      });
      flipEl.addEventListener('pointerdown', handlePointerDown);
      flipEl.addEventListener('pointerup', handlePointerEnd);
      flipEl.addEventListener('pointercancel', handlePointerEnd);

      article.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          toggleFlip();
          resetTilt();
        }
      });

      resetTilt(false);
    }

    // === TAB UI ===
    function setupInfoTabs(root = document) {
      if (!root) {
        return;
      }

      const tabLists = Array.from(root.querySelectorAll('[data-tabs]'));
      if (!tabLists.length) {
        return;
      }

      tabLists.forEach((tabList) => {
        const tabs = Array.from(tabList.querySelectorAll('[role="tab"]'));
        if (!tabs.length) {
          return;
        }

        const escapeSelector = (value = '') => {
          if (typeof CSS !== 'undefined' && typeof CSS.escape === 'function') {
            return CSS.escape(value);
          }
          return String(value).replace(/([ "!#$%&'()*+,./:;<=>?@[\\\]^`{|}~])/g, '\\$1');
        };

        const panels = tabs
          .map((tab) => {
            const panelId = tab.getAttribute('aria-controls');
            return panelId ? root.getElementById(panelId) || root.querySelector(`#${escapeSelector(panelId)}`) : null;
          })
          .filter(Boolean);

        if (!panels.length) {
          return;
        }

        const activateTab = (tab, { setFocus = true } = {}) => {
          if (!tab) {
            return;
          }

          tabs.forEach((btn) => {
            const isActive = btn === tab;
            btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
            btn.classList.toggle('is-active', isActive);
            btn.setAttribute('tabindex', isActive ? '0' : '-1');
          });

          panels.forEach((panel) => {
            const controlsId = tab.getAttribute('aria-controls');
            if (!controlsId || panel.id !== controlsId) {
              panel.hidden = true;
              return;
            }
            panel.hidden = false;
          });

          if (setFocus && typeof tab.focus === 'function') {
            tab.focus({ preventScroll: true });
          }
        };

        const handleKeydown = (event) => {
          const { key } = event;
          const currentIndex = tabs.indexOf(event.currentTarget);
          if (currentIndex === -1) {
            return;
          }

          let nextIndex = null;
          if (key === 'ArrowRight' || key === 'ArrowDown') {
            event.preventDefault();
            nextIndex = (currentIndex + 1) % tabs.length;
          } else if (key === 'ArrowLeft' || key === 'ArrowUp') {
            event.preventDefault();
            nextIndex = (currentIndex + tabs.length - 1) % tabs.length;
          } else if (key === 'Home') {
            event.preventDefault();
            nextIndex = 0;
          } else if (key === 'End') {
            event.preventDefault();
            nextIndex = tabs.length - 1;
          }

          if (nextIndex !== null) {
            activateTab(tabs[nextIndex]);
          }
        };

        tabs.forEach((tab) => {
          tab.addEventListener('click', () => {
            activateTab(tab, { setFocus: false });
          });
          tab.addEventListener('keydown', handleKeydown);
        });

        const initiallySelected = tabs.find((tab) => tab.getAttribute('aria-selected') === 'true') || tabs[0];
        activateTab(initiallySelected, { setFocus: false });
      });
    }

    // === DATA LOADING ===
    async function loadCards() {
      if (!cardsGrid || !cardsStatus) {
        return;
      }

      try {
        cardsStatus.hidden = false;
        cardsStatus.textContent = 'Loading card previews‚Ä¶';

        const response = await fetch('cards/index/by-type.json', { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`Request failed: ${response.status}`);
        }

        const data = await response.json();
        const waifus = Array.isArray(data?.waifu) ? data.waifu : [];

        if (!waifus.length) {
          cardsStatus.textContent = 'Card previews are coming soon.';
          return;
        }

        cardsStatus.textContent = '';
        cardsStatus.hidden = true;
        cardsGrid.innerHTML = '';

        const fragment = document.createDocumentFragment();
        const interactiveArticles = [];
        const customCardBack = 'assets/images/card-back.png';
        const fallbackCardBack = 'assets/images/card-back-default.svg';

        for (const card of waifus) {
          const rarityKey = (card.rarity || 'common').toLowerCase();
          const rarityMeta = RARITY_META[rarityKey] || RARITY_META.common;
          const rarityDatasetKey = rarityMeta.datasetKey || rarityMeta.key;
          const rawRarityName = card.rarityName || rarityMeta.name;
          const rawRarityCode = card.rarityCode || rarityMeta.code;
          const rawRaritySymbol = card.raritySymbol || rarityMeta.symbol;
          const rarityName = escapeHtml(rawRarityName);
          const rarityCode = escapeHtml(rawRarityCode);
          const raritySymbol = escapeHtml(rawRaritySymbol);
          const abilityLines = formatSentences(card.text);
          const flavor = card.flavor ? card.flavor.replace(/^‚Äú|‚Äù$/g, '') : '';
          const moodDisplay = formatMood(card.mood);
          const bondsDisplay = formatBonds(card.bonds);
          const artDefault = card.art?.default;
          const backArt = card.art?.back || customCardBack;
          const hasArt = Boolean(artDefault);

          const roleRaw = getPrimaryRole(card);
          const roleSlug = roleRaw ? roleRaw.toLowerCase().replace(/[^a-z0-9]+/g, '-') : '';
          const roleLabel = roleRaw ? prettifyLabel(roleRaw) : '';
          const roleEsc = roleLabel ? escapeHtml(roleLabel) : '';
          const artRole = hasArt ? `${card.name || 'Card'} artwork` : 'Card back artwork';
          const artMarkup = hasArt
            ? `<img src="${artDefault}" alt="">`
            : `<img src="${backArt}" alt="Waifu Wars card back" class="card-art-img-back" onerror="this.onerror=null;this.src='${fallbackCardBack}';">`;

          const cardTitle = escapeHtml(card.name || 'Unnamed Card');
          const speciesSource = [
            card.species,
            card.girlType,
            card.originType,
            card.origin,
            card.subtype,
            card.affinity?.type,
            card.profile?.species,
            card.profile?.origin,
            card.traits?.species,
            card.traits?.origin
          ].find((value) => typeof value === 'string' && value.trim().length);
          const speciesLabel = speciesSource ? prettifyLabel(speciesSource) : 'Unknown';
          const speciesEsc = escapeHtml(speciesLabel);
          const typeLabel = capitalize(card.type || 'waifu');
          const archetypeChip = escapeHtml((card.archetype || typeLabel).toUpperCase());
          const strategyRaw = typeof card.strategy === 'string' ? card.strategy.trim() : '';
          const strategyLabel = strategyRaw ? prettifyLabel(strategyRaw) : (roleLabel || 'Flexible');
          const strategyEsc = escapeHtml(strategyLabel);
          const moodDisplayEsc = escapeHtml(moodDisplay);
          const bondsDisplayEsc = escapeHtml(bondsDisplay);
          const affectionValue = card.affection ?? '‚Äî';
          const affectionEsc = escapeHtml(String(affectionValue));
          const setLabel = escapeHtml(card.set || 'TBA');
          const idLabel = escapeHtml((card.id || '').toUpperCase());
          const artRoleEsc = escapeHtml(artRole);

          const abilitiesHtml = abilityLines.length
            ? abilityLines.map((line) => `<li>${formatAbilityLine(line)}</li>`).join('')
            : '<li class="card-ability-empty">Ability text coming soon.</li>';

          const flavorHtml = flavor
            ? `<p class="card-flavor">‚Äú${escapeHtml(flavor)}‚Äù</p>`
            : '';

          const rarityStars = rarityMeta.stars || raritySymbol;
          const rarityStarsHtml = rarityStars
            ? `<span class="card-rarity-stars" aria-hidden="true">${escapeHtml(rarityStars)}</span>`
            : '';

          const frontHtml = `
            <div class="card-frame">
              <header class="card-header">
                <span class="card-rarity-badge">
                  <span class="sr-only">${rarityName} rarity</span>
                  <span class="card-rarity-code">${rarityCode}</span>
                </span>
                <div class="card-header-title">
                  ${rarityStarsHtml}
                  <h3 class="card-title">${cardTitle}</h3>
                </div>
                <span class="card-aff-chip">
                  <span class="card-aff-label">AFF</span>
                  <span class="card-aff-value">${affectionEsc}</span>
                </span>
              </header>
              <div class="${hasArt ? 'card-art' : 'card-art card-art--back'}" role="img" aria-label="${artRoleEsc}">
                ${artMarkup}
                <span class="card-chip card-chip--archetype" title="Archetype ${escapeHtml(card.archetype || typeLabel)}">${archetypeChip}</span>
                <span class="card-chip card-chip--strategy" title="Signature effect ${strategyEsc}">${strategyEsc}</span>
                <span class="card-chip card-chip--species" title="Species ${speciesEsc}">${speciesEsc}</span>
              </div>
              <div class="card-text-box">
                <ul class="card-abilities">
                  ${abilitiesHtml}
                </ul>
                ${flavorHtml}
              </div>
              <dl class="card-statline">
                <div>
                  <dt>Bonds</dt>
                  <dd>${bondsDisplayEsc}</dd>
                </div>
                <div>
                  <dt>Mood</dt>
                  <dd>${moodDisplayEsc}</dd>
                </div>
                </dl>
              <footer class="card-footer">Set ${setLabel} ‚Ä¢ ${idLabel}</footer>
            </div>
          `;

          const backHtml = `
            <div class="card-back-frame" aria-hidden="true">
              <div class="card-back-art">
                <img src="${backArt}" alt="Waifu Wars card back" onerror="this.onerror=null;this.src='${fallbackCardBack}';">
              </div>
            </div>
          `;

          const article = document.createElement('article');
          article.className = 'card-display';
          article.dataset.rarity = rarityDatasetKey;
          article.dataset.rarityTier = rarityMeta.key;
          if (card.archetype) {
            article.dataset.archetype = card.archetype.toLowerCase();
          }
          if (roleLabel) {
            article.dataset.role = roleSlug;
          }
          if (card.id) {
            article.dataset.cardId = card.id;
          }
          if (rarityKey === 'event') {
            article.dataset.rarityVariant = 'event';
          }
          const rarityTheme = (card.rarityTheme || '').toLowerCase();
          if (rarityTheme) {
            article.dataset.rarityTheme = rarityTheme;
          }
          if (card.rarityCode) {
            article.dataset.rarityCode = rawRarityCode;
          }
          if (card.rarityName) {
            article.dataset.rarityName = rawRarityName;
          }
          article.setAttribute('role', 'button');
          article.setAttribute('tabindex', '0');
          article.setAttribute('aria-pressed', 'false');
          article.setAttribute('aria-label', `${card.name || 'Card'} preview. Drag sideways to flip.`);
          article.style.setProperty('--cursor-x', '0');
          article.style.setProperty('--cursor-y', '0');

          article.innerHTML = `
            <div class="card-flip">
              <div class="card-face card-face--front">
                ${frontHtml}
              </div>
              <div class="card-face card-face--back">
                ${backHtml}
              </div>
            </div>
          `;

          fragment.appendChild(article);
          interactiveArticles.push(article);
        }

        cardsGrid.appendChild(fragment);

        balanceAbilityText(cardsGrid);
        fitAllTitles(cardsGrid);
        detectAllOverflow(cardsGrid);

        requestAnimationFrame(() => {
          interactiveArticles.forEach((article) => {
            setupInteractiveCard(article);
          });
        });
      } catch (error) {
        cardsStatus.textContent = 'Could not load cards right now. Try refreshing in a moment.';
        cardsStatus.hidden = false;
        console.error(error);
      }
    }

    // === LIFECYCLE ===
    window.addEventListener('resize', () => {
      balanceAbilityText(cardsGrid);
      fitAllTitles(cardsGrid);
      detectAllOverflow(cardsGrid);
    });

    if (document.fonts && typeof document.fonts.ready?.then === 'function') {
      document.fonts.ready.then(() => {
        balanceAbilityText(cardsGrid);
        fitAllTitles(cardsGrid);
        detectAllOverflow(cardsGrid);
      }).catch(() => {});
    }

    setupInfoTabs();
    loadCards();
  </script>
</body>
</html>
