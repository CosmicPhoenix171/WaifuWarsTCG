<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Waifu Wars TCG – Emotional Strategy Card Game</title>
  <meta name="description" content="Waifu Wars TCG: fast tactical anime card game where Bonds, moods, and archetypes forge dramatic comebacks." />
  <meta name="color-scheme" content="dark light" />
  <meta name="theme-color" content="#ee2e8b" />
  <meta property="og:title" content="Waifu Wars TCG" />
  <meta property="og:description" content="Tactical anime card battler with bonds, mood states, and archetype matchups." />
  <meta property="og:type" content="website" />
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%236d5dfc'/%3E%3Cpath d='M20 38c6 6 12 6 18 0 5-5 5-13 0-18-4-4-10-4-14 0-5 5-5 13 0 18z' fill='%23fff'/%3E%3C/svg%3E" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>
  <header class="site-header">
    <div class="container nav">
      <div class="brand">
        <span class="logo">Waifu Wars</span>
        <span class="tag">TCG</span>
      </div>
      <nav class="menu" aria-label="Primary">
        <a href="#battle-loop">Battle Loop</a>
        <a href="#emotional-engine">Emotional Engine</a>
        <a href="#features">Features</a>
        <a href="#join">Join</a>
      </nav>
    </div>
  </header>

  <main id="main">
    <section class="hero">
      <div class="container hero-inner">
        <div class="hero-copy">
          <h1 class="title">Outplay With Emotion</h1>
          <p class="subtitle">A tactical anime card battler where Bonds, mood swings, and archetype matchups decide every duel.</p>
          <div class="cta-row">
            <a class="btn btn-primary" href="#battle-loop">Learn How To Play</a>
            <a class="btn btn-ghost" href="#features">See Features</a>
          </div>
          <div class="hero-highlights">
            <div class="chip">Bonds-powered abilities</div>
            <div class="chip">Neutral → Dere → Extreme</div>
            <div class="chip">Passion • Stoic • Heart</div>
          </div>
        </div>
        <div class="hero-art" aria-hidden="true">
          <div class="card-mock one"></div>
          <div class="card-mock two"></div>
          <div class="card-mock three"></div>
        </div>
      </div>
    </section>

    <section id="battle-loop" class="battle-loop">
      <div class="container">
        <h2 class="section-title">Battle Loop Snapshot</h2>
        <ol class="loop">
          <li><strong>Draw Phase:</strong> Draw 1 card; fire start-of-turn triggers.</li>
          <li><strong>Main Phase:</strong> Summon up to 3 waifus, play Support, set Traps.</li>
          <li><strong>Battle Phase:</strong> Declare attacks; Affection damage & bond checks.</li>
          <li><strong>End Phase:</strong> Resolve lingering effects, update Bonds & mood.</li>
        </ol>
        <p class="round-note">Round ends if you lose three waifus or finish with none in play. Simultaneous knockout? Narrative privilege awards you the win.</p>
      </div>
    </section>

    <section id="emotional-engine" class="engine">
      <div class="container">
        <h2 class="section-title">Emotional Engine</h2>
        <div class="engine-grid">
          <div class="engine-card">
            <h3>Affection (HP)</h3>
            <p>Each waifu’s durability. Drop to 0 and she exits—unless a Final Stand bends fate.</p>
          </div>
          <div class="engine-card">
            <h3>Bonds</h3>
            <p>Relationship meter fueling Confessions, meltdowns, and clutch survival effects.</p>
          </div>
          <div class="engine-card">
            <h3>Mood States</h3>
            <p>Neutral → Dere → Extreme escalations unlock power spikes & alternate art moments.</p>
          </div>
          <div class="engine-card">
            <h3>Bond Cards</h3>
            <p>Create Lover / Rival / Mentor links for shared triggers and combo supers.</p>
          </div>
        </div>
      </div>
    </section>

    <section id="features" class="features">
      <div class="container">
        <h2 class="section-title">What Makes It Different</h2>
        <div class="grid">
          <article class="feature">
            <h3>Emotion-Driven Combat</h3>
            <p>Build Bonds, trigger Confessions, and pivot moods to flip the battlefield in your favor.</p>
          </article>
          <article class="feature">
            <h3>Clear Archetypes</h3>
            <p>Tsundere strikes, Kuudere control, Yandere deletion—distinct playstyles that stay balanced.</p>
          </article>
          <article class="feature">
            <h3>Collect • Trade • Flex</h3>
            <p>Open packs with animated reveals, complete sets, and trade safely in the hub.</p>
          </article>
          <article class="feature">
            <h3>Made for Web & Mobile</h3>
            <p>Responsive UI, touch-friendly layouts, and readable typography out of the box.</p>
          </article>
        </div>
      </div>
    </section>

    <section id="cards" class="cards-gallery">
      <div class="container">
        <h2 class="section-title">Card Spotlight</h2>
        <p class="cards-intro">Preview a sampling of Waifu archetypes—each colorful personality brings unique stats, moods, and tags to weave into your bond-driven strategy.</p>
        <div id="cards-status" class="cards-status" role="status" aria-live="polite">Loading card previews…</div>
        <div id="cards-grid" class="cards-grid" aria-live="polite"></div>
      </div>
    </section>

    <section class="callouts">
      <div class="container">
        <div class="callout">
          <div class="callout-copy">
            <h3>Meet the Archetypes</h3>
            <p>Learn the macro families—Passion Surge, Stoic Control, Heart Guard—and how they create soft matchups.</p>
            <a class="btn btn-secondary" href="#features">Explore Archetypes</a>
          </div>
        </div>
        <div class="callout alt">
          <div class="callout-copy">
            <h3>Build Your First Deck</h3>
            <p>Start with a Tsundere reactive shell or a Deredere support core—simple rules, deep strategy.</p>
            <a class="btn btn-secondary" href="#cards">See Cards</a>
          </div>
        </div>
      </div>
    </section>

    <section id="join" class="cta">
      <div class="container">
        <h2 class="section-title">Join The Journey</h2>
        <p>Follow development and get notified when the alpha opens.</p>
        <div class="cta-row">
          <a class="btn btn-primary" href="#">Join Waitlist</a>
          <a class="btn btn-ghost" href="#features">Learn More</a>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <div>© <span id="year"></span> Waifu Wars TCG</div>
      <div class="footer-links">
        <a href="#join">Contact</a>
        <a href="https://github.com/CosmicPhoenix171/WaifuWarsTCG" target="_blank" rel="noopener">GitHub</a>
      </div>
    </div>
  </footer>

  <script type="module">
    // === DOM REFERENCES ===
    const yearEl = document.getElementById('year');
    const cardsGrid = document.getElementById('cards-grid');
    const cardsStatus = document.getElementById('cards-status');

    if (yearEl) {
      yearEl.textContent = new Date().getFullYear();
    }

    // === CONFIGURATION ===
  const RARITY_META = {
      common: {
        key: 'common',
        datasetKey: 'common',
        name: 'Common',
        code: 'C',
        symbol: '●',
        stars: '•'
      },
      rare: {
        key: 'rare',
        datasetKey: 'rare',
        name: 'Rare',
        code: 'R',
        symbol: '★',
        stars: '★'
      },
      'super-rare': {
        key: 'super-rare',
        datasetKey: 'super-rare',
        name: 'Super Rare',
        code: 'SR',
        symbol: '★★',
        stars: '★★'
      },
      'special-super-rare': {
        key: 'special-super-rare',
        datasetKey: 'special-super-rare',
        name: 'Special Super Rare',
        code: 'SSR',
        symbol: '★★★',
        stars: '★★★'
      },
      ultra: {
        key: 'ultra',
        datasetKey: 'ultra',
        name: 'Ultra Rare',
        code: 'UR',
        symbol: '✪',
        stars: '✪'
      },
      event: {
        key: 'event',
        datasetKey: 'ultra',
        name: 'Event Exclusive',
        code: 'EX',
        symbol: '✪',
        stars: '✪'
      }
    };

    // === UTILITY HELPERS ===
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function escapeHtml(str = '') {
      return String(str).replace(/[&<>"']/g, (ch) => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[ch]));
    }

    function capitalize(word = '') {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }

    function formatSentences(text) {
      if (!text) {
        return [];
      }
      return String(text)
        .split(/(?:\r?\n|\r)+|(?<=[.!?])\s+/)
        .map((line) => line.trim())
        .filter(Boolean);
    }

    function formatBonds(bonds) {
      if (!bonds) {
        return '—';
      }
      const start = typeof bonds.start === 'number' ? bonds.start : null;
      const max = typeof bonds.max === 'number' ? bonds.max : null;
      if (start !== null && max !== null) {
        return `${start} / ${max}`;
      }
      if (max !== null) {
        return `${max}`;
      }
      return '—';
    }

    function formatMood(mood) {
      if (!mood) {
        return '— / —';
      }
      const dere = mood.dere ?? '—';
      const extreme = mood.extreme ?? '—';
      return `${dere} / ${extreme}`;
    }

    function prettifyLabel(value = '') {
      return value
        .toString()
        .replace(/[_-]+/g, ' ')
        .replace(/\b\w/g, (ch) => ch.toUpperCase())
        .trim();
    }

    function getPrimaryRole(card = {}) {
      if (!card) {
        return '';
      }
      if (card.role) {
        return card.role;
      }
      if (typeof card.strategy === 'string' && card.strategy.trim().length) {
        return card.strategy;
      }
      return '';
    }

    function decorateAbilityText(text = '') {
      let output = escapeHtml(text);
      const replacements = [
        { pattern: /\{?BOND\}?/gi, markup: '<span class="card-icon card-icon--bond" aria-hidden="true"></span><span class="sr-only">Bond</span>' },
        { pattern: /\bATK\b/g, markup: '<span class="card-icon card-icon--atk" aria-hidden="true"></span><span class="sr-only">Attack</span>' },
        { pattern: /\bDEF\b/g, markup: '<span class="card-icon card-icon--def" aria-hidden="true"></span><span class="sr-only">Defense</span>' },
        { pattern: /\bHP\b/gi, markup: '<span class="card-icon card-icon--hp" aria-hidden="true"></span><span class="sr-only">Health</span>' },
        { pattern: /\bAFFECTION\b/gi, markup: '<span class="card-icon card-icon--aff" aria-hidden="true"></span><span class="sr-only">Affection</span>' }
      ];
      replacements.forEach(({ pattern, markup }) => {
        output = output.replace(pattern, markup);
      });
      return output;
    }

    function formatAbilityLine(line = '') {
      const trimmed = line.trim();
      if (!trimmed) {
        return '';
      }
      const keywordMatch = trimmed.match(/^([^:\u2014\u2013\-]{1,48}?)[\s]*(?:[:\u2014\u2013\-])\s+(.+)$/u);
      if (keywordMatch) {
        const keyword = decorateAbilityText(keywordMatch[1]);
        const body = decorateAbilityText(keywordMatch[2]);
        return `<span class="card-ability-keyword">${keyword}<span aria-hidden="true"> —</span></span><span class="card-ability-body">${body}</span>`;
      }
      return `<span class="card-ability-body">${decorateAbilityText(trimmed)}</span>`;
    }

    // === LAYOUT HELPERS ===
    function balanceAbilityText(root = document) {
      if (!root || typeof root.querySelectorAll !== 'function') return;
      root.querySelectorAll('.card-text-box').forEach((textBox) => {
        if (textBox.dataset.fluid === 'true') return; // skip auto-fit for fluid boxes
        const abilities = textBox.querySelector('.card-abilities');
        if (!abilities) return;

        // Reset any previous inline tweaks
        abilities.style.fontSize = '';
        abilities.style.lineHeight = '';
        abilities.style.gap = '';
        const flavorEl = textBox.querySelector('.card-flavor');
        if (flavorEl) flavorEl.style.display = '';

        const cs = getComputedStyle(abilities);
        let fontSize = parseFloat(cs.fontSize) || 14;
        let lineHeight = parseFloat(cs.lineHeight) || Math.max(1.2, (fontSize * 1.35));
        let gap = parseFloat((cs.gap || '0').toString()) || 7.2; // approx .45rem

  const minFont = 8.5;
  const minLine = Math.max(1.02, fontSize * 1.12);
  const minGap = 1; // px

        // Helper to check overflow
        const overflows = () => textBox.scrollHeight > textBox.clientHeight + 1;

        // Step 1: shrink font size
        while (overflows() && fontSize > minFont) {
          fontSize -= 0.5;
          abilities.style.fontSize = `${fontSize}px`;
        }

        // Step 2: tighten line-height
        // Re-read lineHeight in px for consistency
        lineHeight = parseFloat(getComputedStyle(abilities).lineHeight) || lineHeight;
        while (overflows() && lineHeight > minLine) {
          lineHeight -= 0.5;
          abilities.style.lineHeight = `${lineHeight}px`;
        }

        // Step 3: reduce gap between ability items
        gap = parseFloat(getComputedStyle(abilities).gap) || gap;
        while (overflows() && gap > minGap) {
          gap -= 1;
          abilities.style.gap = `${gap}px`;
        }

        // Step 4: hide flavor text as last resort
        if (overflows() && flavorEl) {
          flavorEl.style.display = 'none';
        }

        // Final pass: tiny font bump down if still overflowing
        let guard = 10;
        while (overflows() && guard--) {
          fontSize -= 0.25;
          abilities.style.fontSize = `${Math.max(minFont - 1.5, fontSize)}px`;
        }
      });
    }

    function fitCardTitle(titleEl) {
      if (!titleEl) return;
      // Preserve original inline values we touch
      const original = {
        display: titleEl.style.display,
        webkitLineClamp: titleEl.style.webkitLineClamp,
        lineClamp: titleEl.style.lineClamp,
        webkitBoxOrient: titleEl.style.webkitBoxOrient,
        overflow: titleEl.style.overflow,
        fontSize: titleEl.style.fontSize
      };

      const computed = getComputedStyle(titleEl);
      let fontSize = parseFloat(computed.fontSize) || 18;
      const minFont = 12; // don't go too tiny

      // Temporarily remove clamp to measure full height
      titleEl.style.display = 'block';
      titleEl.style.webkitLineClamp = 'unset';
      titleEl.style.lineClamp = 'unset';
      titleEl.style.webkitBoxOrient = 'unset';
      titleEl.style.overflow = 'visible';

      // Compute allowed height for two lines
      const lhPx = (() => {
        const lh = computed.lineHeight;
        const num = parseFloat(lh);
        if (lh.endsWith('px')) return num;
        // fallback: scale of font size
        return (parseFloat(computed.fontSize) || 18) * 1.3;
      })();
      const allowed = lhPx * 2.05; // slightly generous

      // Reduce font until fits within 2 lines
      while (titleEl.scrollHeight > allowed && fontSize > minFont) {
        fontSize -= 0.5;
        titleEl.style.fontSize = `${fontSize}px`;
      }

      // Restore clamp behavior
      titleEl.style.display = original.display || '-webkit-box';
      titleEl.style.webkitLineClamp = original.webkitLineClamp || '2';
      titleEl.style.lineClamp = original.lineClamp || '2';
      titleEl.style.webkitBoxOrient = original.webkitBoxOrient || 'vertical';
      titleEl.style.overflow = original.overflow || 'hidden';
      // Keep the adjusted fontSize
    }

    function fitAllTitles(root = document) {
      const titles = root.querySelectorAll('.card-title');
      titles.forEach(fitCardTitle);
    }
    // === OVERFLOW DETECTION ===
    function titleWouldOverflow(titleEl) {
      if (!titleEl) return false;
      const prev = {
        display: titleEl.style.display,
        webkitLineClamp: titleEl.style.webkitLineClamp,
        lineClamp: titleEl.style.lineClamp,
        webkitBoxOrient: titleEl.style.webkitBoxOrient,
        overflow: titleEl.style.overflow
      };
      const computed = getComputedStyle(titleEl);
      // Temporarily remove clamp & overflow to measure full height
      titleEl.style.display = 'block';
      titleEl.style.webkitLineClamp = 'unset';
      titleEl.style.lineClamp = 'unset';
      titleEl.style.webkitBoxOrient = 'unset';
      titleEl.style.overflow = 'visible';
      const lhPx = (() => {
        const lh = computed.lineHeight;
        const num = parseFloat(lh);
        if (lh.endsWith('px')) return num;
        return (parseFloat(computed.fontSize) || 18) * 1.3;
      })();
      const allowed = lhPx * 2.05;
      const wouldOverflow = titleEl.scrollHeight > allowed + 0.5;
      // restore
      titleEl.style.display = prev.display || '-webkit-box';
      titleEl.style.webkitLineClamp = prev.webkitLineClamp || '2';
      titleEl.style.lineClamp = prev.lineClamp || '2';
      titleEl.style.webkitBoxOrient = prev.webkitBoxOrient || 'vertical';
      titleEl.style.overflow = prev.overflow || 'hidden';
      return wouldOverflow;
    }

    function detectCardOverflow(article) {
      if (!article) return;
      const textBox = article.querySelector('.card-text-box');
      const title = article.querySelector('.card-title');
      let overflow = false;
      if (textBox) {
        overflow = overflow || (textBox.scrollHeight > textBox.clientHeight + 1);
      }
      if (title) {
        overflow = overflow || titleWouldOverflow(title);
      }
      if (overflow) {
        article.dataset.overflow = 'true';
      } else {
        delete article.dataset.overflow;
      }
    }

    function detectAllOverflow(root = document) {
      const cards = root.querySelectorAll('.card-display');
      cards.forEach(detectCardOverflow);
    }

    // === INTERACTION ===
    function setupInteractiveCard(article) {
      const flipEl = article.querySelector('.card-flip');
      if (!flipEl) {
        return;
      }

      const state = {
        pointerId: null,
        startX: 0,
        startY: 0,
        isDragging: false,
        hasFlipped: false,
        isFlipped: flipEl.classList.contains('is-flipped'),
        resetTimer: null
      };

      article.setAttribute('aria-pressed', state.isFlipped ? 'true' : 'false');

      const maxTiltX = 10;
      const maxTiltY = 16;

      const updateCursorVars = (nx = 0, ny = 0) => {
        article.style.setProperty('--cursor-x', Number.isFinite(nx) ? nx.toFixed(3) : '0');
        article.style.setProperty('--cursor-y', Number.isFinite(ny) ? ny.toFixed(3) : '0');
      };
      updateCursorVars(0, 0);

      const resetTilt = (smooth = true) => {
        if (state.resetTimer) {
          clearTimeout(state.resetTimer);
          state.resetTimer = null;
        }

        if (smooth) {
          flipEl.style.transition = 'transform .26s ease, box-shadow .26s ease';
          flipEl.style.setProperty('--tilt-x', '0deg');
          flipEl.style.setProperty('--tilt-y', '0deg');
          flipEl.style.setProperty('--tilt-scale', '1');
          state.resetTimer = setTimeout(() => {
            flipEl.style.transition = '';
            state.resetTimer = null;
          }, 260);
        } else {
          flipEl.style.transition = '';
          flipEl.style.setProperty('--tilt-x', '0deg');
          flipEl.style.setProperty('--tilt-y', '0deg');
          flipEl.style.setProperty('--tilt-scale', '1');
        }

        updateCursorVars(0, 0);
      };

      const toggleFlip = () => {
        state.isFlipped = !state.isFlipped;
        flipEl.classList.toggle('is-flipped', state.isFlipped);
        article.setAttribute('aria-pressed', state.isFlipped ? 'true' : 'false');
      };

      const handleHoverTilt = (event) => {
        if (state.isDragging) {
          return;
        }

        const rect = flipEl.getBoundingClientRect();
        const relativeX = (event.clientX - rect.left) / rect.width;
        const relativeY = (event.clientY - rect.top) / rect.height;
        const tiltY = clamp((relativeX - 0.5) * 2 * maxTiltY, -maxTiltY, maxTiltY);
        const tiltX = clamp((0.5 - relativeY) * 2 * maxTiltX, -maxTiltX, maxTiltX);
        const normX = clamp((relativeX - 0.5) * 2, -1, 1);
        const normY = clamp((0.5 - relativeY) * 2, -1, 1);

        flipEl.style.setProperty('--tilt-x', `${tiltX.toFixed(2)}deg`);
        flipEl.style.setProperty('--tilt-y', `${tiltY.toFixed(2)}deg`);
        flipEl.style.setProperty('--tilt-scale', '1.02');
        updateCursorVars(normX, normY);
      };

      const handlePointerDown = (event) => {
        event.preventDefault();

        if (document.activeElement !== article && typeof article.focus === 'function') {
          article.focus({ preventScroll: true });
        }

        state.pointerId = event.pointerId;
        state.startX = event.clientX;
        state.startY = event.clientY;
        state.isDragging = true;
        state.hasFlipped = false;

        flipEl.setPointerCapture(event.pointerId);
        flipEl.classList.add('is-grabbing');
        flipEl.style.transition = '';
        flipEl.style.setProperty('--tilt-scale', '1');
        updateCursorVars(0, 0);
      };

      const handlePointerMove = (event) => {
        if (state.isDragging) {
          if (state.pointerId !== event.pointerId) {
            return;
          }

          const deltaX = event.clientX - state.startX;
          const deltaY = event.clientY - state.startY;

          if (!state.hasFlipped && Math.abs(deltaX) > 80 && Math.abs(deltaY) < 120) {
            toggleFlip();
            state.hasFlipped = true;
            resetTilt(false);
          } else if (!state.hasFlipped) {
            const dragTilt = clamp(deltaX / 12, -10, 10);
            flipEl.style.setProperty('--tilt-y', `${dragTilt.toFixed(2)}deg`);
          }

          const rect = flipEl.getBoundingClientRect();
          const relativeX = (event.clientX - rect.left) / rect.width;
          const relativeY = (event.clientY - rect.top) / rect.height;
          const normX = clamp((relativeX - 0.5) * 2, -1, 1);
          const normY = clamp((0.5 - relativeY) * 2, -1, 1);
          updateCursorVars(normX, normY);
        } else {
          handleHoverTilt(event);
        }
      };

      const handlePointerEnd = (event) => {
        if (state.pointerId !== event.pointerId) {
          return;
        }

        flipEl.releasePointerCapture(event.pointerId);
        state.pointerId = null;
        state.isDragging = false;
        flipEl.classList.remove('is-grabbing');
        resetTilt();
      };

      flipEl.addEventListener('pointerenter', handleHoverTilt);
      flipEl.addEventListener('pointermove', handlePointerMove);
      flipEl.addEventListener('pointerleave', () => {
        if (state.isDragging) {
          return;
        }
        resetTilt();
      });
      flipEl.addEventListener('pointerdown', handlePointerDown);
      flipEl.addEventListener('pointerup', handlePointerEnd);
      flipEl.addEventListener('pointercancel', handlePointerEnd);

      article.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          toggleFlip();
          resetTilt();
        }
      });

      resetTilt(false);
    }

    // === DATA LOADING ===
    async function loadCards() {
      if (!cardsGrid || !cardsStatus) {
        return;
      }

      try {
        cardsStatus.hidden = false;
        cardsStatus.textContent = 'Loading card previews…';

        const response = await fetch('cards/index/by-type.json', { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`Request failed: ${response.status}`);
        }

        const data = await response.json();
        const waifus = Array.isArray(data?.waifu) ? data.waifu : [];

        if (!waifus.length) {
          cardsStatus.textContent = 'Card previews are coming soon.';
          return;
        }

        cardsStatus.textContent = '';
        cardsStatus.hidden = true;
        cardsGrid.innerHTML = '';

        const fragment = document.createDocumentFragment();
        const interactiveArticles = [];
        const customCardBack = 'assets/images/card-back.png';
        const fallbackCardBack = 'assets/images/card-back-default.svg';

        for (const card of waifus) {
          const rarityKey = (card.rarity || 'common').toLowerCase();
          const rarityMeta = RARITY_META[rarityKey] || RARITY_META.common;
          const rarityDatasetKey = rarityMeta.datasetKey || rarityMeta.key;
          const rawRarityName = card.rarityName || rarityMeta.name;
          const rawRarityCode = card.rarityCode || rarityMeta.code;
          const rawRaritySymbol = card.raritySymbol || rarityMeta.symbol;
          const rarityName = escapeHtml(rawRarityName);
          const rarityCode = escapeHtml(rawRarityCode);
          const raritySymbol = escapeHtml(rawRaritySymbol);
          const abilityLines = formatSentences(card.text);
          const flavor = card.flavor ? card.flavor.replace(/^“|”$/g, '') : '';
          const moodDisplay = formatMood(card.mood);
          const bondsDisplay = formatBonds(card.bonds);
          const artDefault = card.art?.default;
          const backArt = card.art?.back || customCardBack;
          const hasArt = Boolean(artDefault);

          const roleRaw = getPrimaryRole(card);
          const roleSlug = roleRaw ? roleRaw.toLowerCase().replace(/[^a-z0-9]+/g, '-') : '';
          const roleLabel = roleRaw ? prettifyLabel(roleRaw) : '';
          const roleEsc = roleLabel ? escapeHtml(roleLabel) : '';
          const roleBadge = roleLabel
            ? `<span class="card-role-badge" data-role="${escapeHtml(roleSlug)}" title="${roleEsc}"><span aria-hidden="true">${roleEsc}</span><span class="sr-only">${roleEsc} role</span></span>`
            : '';

          const artRole = hasArt ? `${card.name || 'Card'} artwork` : 'Card back artwork';
          const artMarkup = hasArt
            ? `<img src="${artDefault}" alt="">`
            : `<img src="${backArt}" alt="Waifu Wars card back" class="card-art-img-back" onerror="this.onerror=null;this.src='${fallbackCardBack}';">`;

          const cardTitle = escapeHtml(card.name || 'Unnamed Card');
          const speciesSource = [
            card.species,
            card.girlType,
            card.originType,
            card.origin,
            card.subtype,
            card.affinity?.type,
            card.profile?.species,
            card.profile?.origin,
            card.traits?.species,
            card.traits?.origin
          ].find((value) => typeof value === 'string' && value.trim().length);
          const speciesLabel = speciesSource ? prettifyLabel(speciesSource) : 'Unknown';
          const speciesEsc = escapeHtml(speciesLabel);
          const typeLabel = capitalize(card.type || 'waifu');
          const archetypeChip = escapeHtml((card.archetype || typeLabel).toUpperCase());
          const strategyRaw = typeof card.strategy === 'string' ? card.strategy.trim() : '';
          const strategyLabel = strategyRaw ? prettifyLabel(strategyRaw) : (roleLabel || 'Flexible');
          const strategyEsc = escapeHtml(strategyLabel);
          const moodDisplayEsc = escapeHtml(moodDisplay);
          const bondsDisplayEsc = escapeHtml(bondsDisplay);
          const affectionValue = card.affection ?? '—';
          const affectionEsc = escapeHtml(String(affectionValue));
          const setLabel = escapeHtml(card.set || 'TBA');
          const idLabel = escapeHtml((card.id || '').toUpperCase());
          const artRoleEsc = escapeHtml(artRole);

          const abilitiesHtml = abilityLines.length
            ? abilityLines.map((line) => `<li>${formatAbilityLine(line)}</li>`).join('')
            : '<li class="card-ability-empty">Ability text coming soon.</li>';

          const flavorHtml = flavor
            ? `<p class="card-flavor">“${escapeHtml(flavor)}”</p>`
            : '';

          const rarityStars = rarityMeta.stars || raritySymbol;
          const rarityStarsHtml = rarityStars
            ? `<span class="card-rarity-stars" aria-hidden="true">${escapeHtml(rarityStars)}</span>`
            : '';

          const frontHtml = `
            <div class="card-frame">
              <header class="card-header">
                <span class="card-rarity-badge">
                  <span class="sr-only">${rarityName} rarity</span>
                  <span class="card-rarity-code">${rarityCode}</span>
                </span>
                <div class="card-header-title">
                  ${rarityStarsHtml}
                  <h3 class="card-title">${cardTitle}</h3>
                </div>
                <span class="card-aff-chip">
                  <span class="card-aff-label">AFF</span>
                  <span class="card-aff-value">${affectionEsc}</span>
                </span>
              </header>
              <div class="${hasArt ? 'card-art' : 'card-art card-art--back'}" role="img" aria-label="${artRoleEsc}">
                ${roleBadge}
                ${artMarkup}
                <span class="card-chip card-chip--archetype" title="Archetype ${escapeHtml(card.archetype || typeLabel)}">${archetypeChip}</span>
                <span class="card-chip card-chip--strategy" title="Signature effect ${strategyEsc}">${strategyEsc}</span>
                <span class="card-chip card-chip--species" title="Species ${speciesEsc}">${speciesEsc}</span>
              </div>
              <div class="card-text-box">
                <ul class="card-abilities">
                  ${abilitiesHtml}
                </ul>
                ${flavorHtml}
              </div>
              <dl class="card-statline">
                <div>
                  <dt>Affection</dt>
                  <dd>${affectionEsc}</dd>
                </div>
                <div>
                  <dt>Bonds</dt>
                  <dd>${bondsDisplayEsc}</dd>
                </div>
                <div>
                  <dt>Mood</dt>
                  <dd>${moodDisplayEsc}</dd>
                </div>
                </dl>
              <footer class="card-footer">Set ${setLabel} • ${idLabel}</footer>
            </div>
          `;

          const backHtml = `
            <div class="card-back-frame" aria-hidden="true">
              <div class="card-back-art">
                <img src="${backArt}" alt="Waifu Wars card back" onerror="this.onerror=null;this.src='${fallbackCardBack}';">
              </div>
            </div>
          `;

          const article = document.createElement('article');
          article.className = 'card-display';
          article.dataset.rarity = rarityDatasetKey;
          article.dataset.rarityTier = rarityMeta.key;
          if (card.archetype) {
            article.dataset.archetype = card.archetype.toLowerCase();
          }
          if (roleLabel) {
            article.dataset.role = roleSlug;
          }
          if (card.id) {
            article.dataset.cardId = card.id;
          }
          if (rarityKey === 'event') {
            article.dataset.rarityVariant = 'event';
          }
          const rarityTheme = (card.rarityTheme || '').toLowerCase();
          if (rarityTheme) {
            article.dataset.rarityTheme = rarityTheme;
          }
          if (card.rarityCode) {
            article.dataset.rarityCode = rawRarityCode;
          }
          if (card.rarityName) {
            article.dataset.rarityName = rawRarityName;
          }
          article.setAttribute('role', 'button');
          article.setAttribute('tabindex', '0');
          article.setAttribute('aria-pressed', 'false');
          article.setAttribute('aria-label', `${card.name || 'Card'} preview. Drag sideways to flip.`);
          article.style.setProperty('--cursor-x', '0');
          article.style.setProperty('--cursor-y', '0');

          article.innerHTML = `
            <div class="card-flip">
              <div class="card-face card-face--front">
                ${frontHtml}
              </div>
              <div class="card-face card-face--back">
                ${backHtml}
              </div>
            </div>
          `;

          fragment.appendChild(article);
          interactiveArticles.push(article);
        }

        cardsGrid.appendChild(fragment);

        balanceAbilityText(cardsGrid);
        fitAllTitles(cardsGrid);
        detectAllOverflow(cardsGrid);

        requestAnimationFrame(() => {
          interactiveArticles.forEach((article) => {
            setupInteractiveCard(article);
          });
        });
      } catch (error) {
        cardsStatus.textContent = 'Could not load cards right now. Try refreshing in a moment.';
        cardsStatus.hidden = false;
        console.error(error);
      }
    }

    // === LIFECYCLE ===
    window.addEventListener('resize', () => {
      balanceAbilityText(cardsGrid);
      fitAllTitles(cardsGrid);
      detectAllOverflow(cardsGrid);
    });

    if (document.fonts && typeof document.fonts.ready?.then === 'function') {
      document.fonts.ready.then(() => {
        balanceAbilityText(cardsGrid);
        fitAllTitles(cardsGrid);
        detectAllOverflow(cardsGrid);
      }).catch(() => {});
    }

    loadCards();
  </script>
</body>
</html>
