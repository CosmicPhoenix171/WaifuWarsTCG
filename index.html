<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <title>Waifu Wars TCG – Emotional Strategy Card Game</title>
   <meta name="description" content="Waifu Wars TCG: fast tactical anime card game where Bonds, moods, and archetypes forge dramatic comebacks." />
   <meta name="color-scheme" content="dark light" />
   <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%236d5dfc'/%3E%3Cpath d='M20 38c6 6 12 6 18 0 5-5 5-13 0-18-4-4-10-4-14 0-5 5-5 13 0 18z' fill='%23fff'/%3E%3C/svg%3E" />
  <meta name="description" content="Waifu Wars TCG — a sleek, modern anime card battler with emotional mechanics, bond meters, and dramatic trope moments." />
  <meta property="og:title" content="Waifu Wars TCG" />
  <meta property="og:description" content="Tactical anime card battler with bonds, mood states, and archetype matchups." />
  <meta property="og:type" content="website" />
  <meta name="theme-color" content="#ee2e8b" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>
  <header class="site-header">
    <div class="container nav">
      <div class="brand">
        <span class="logo">Waifu Wars</span>
        <span class="tag">TCG</span>
      </div>
      <nav class="menu" aria-label="Primary">
        <a href="#battle-loop">Battle Loop</a>
        <a href="#emotional-engine">Emotional Engine</a>
        <a href="#features">Features</a>
        <a href="#join">Join</a>
      </nav>
    </div>
  </header>

  <main id="main">
    <section class="hero">
      <div class="container hero-inner">
        <div class="hero-copy">
          <h1 class="title">Outplay With Emotion</h1>
          <p class="subtitle">A tactical anime card battler where Bonds, mood swings, and archetype matchups decide every duel.</p>
          <div class="cta-row">
            <a class="btn btn-primary" href="#battle-loop">Learn How To Play</a>
            <a class="btn btn-ghost" href="#features">See Features</a>
          </div>
          <div class="hero-highlights">
            <div class="chip">Bonds-powered abilities</div>
            <div class="chip">Neutral → Dere → Extreme</div>
            <div class="chip">Passion • Stoic • Heart</div>
          </div>
        </div>
        <div class="hero-art" aria-hidden="true">
          <div class="card-mock one"></div>
          <div class="card-mock two"></div>
          <div class="card-mock three"></div>
        </div>
      </div>
    </section>

    <section id="battle-loop" class="battle-loop">
      <div class="container">
        <h2 class="section-title">Battle Loop Snapshot</h2>
        <ol class="loop">
          <li><strong>Draw Phase:</strong> Draw 1 card; fire start-of-turn triggers.</li>
          <li><strong>Main Phase:</strong> Summon up to 3 waifus, play Support, set Traps.</li>
          <li><strong>Battle Phase:</strong> Declare attacks; Affection damage & bond checks.</li>
          <li><strong>End Phase:</strong> Resolve lingering effects, update Bonds & mood.</li>
        </ol>
        <p class="round-note">Round ends if you lose three waifus or finish with none in play. Simultaneous knockout? Narrative privilege awards you the win.</p>
      </div>
    </section>

    <section id="emotional-engine" class="engine">
      <div class="container">
        <h2 class="section-title">Emotional Engine</h2>
        <div class="engine-grid">
          <div class="engine-card">
            <h3>Affection (HP)</h3>
            <p>Each waifu’s durability. Drop to 0 and she exits—unless a Final Stand bends fate.</p>
          </div>
          <div class="engine-card">
            <h3>Bonds</h3>
            <p>Relationship meter fueling Confessions, meltdowns, and clutch survival effects.</p>
          </div>
          <div class="engine-card">
            <h3>Mood States</h3>
            <p>Neutral → Dere → Extreme escalations unlock power spikes & alternate art moments.</p>
          </div>
          <div class="engine-card">
            <h3>Bond Cards</h3>
            <p>Create Lover / Rival / Mentor links for shared triggers and combo supers.</p>
          </div>
        </div>
      </div>
    </section>

    <section id="features" class="features">
      <div class="container">
        <h2 class="section-title">What Makes It Different</h2>
        <div class="grid">
          <article class="feature">
            <h3>Emotion-Driven Combat</h3>
            <p>Build Bonds, trigger Confessions, and pivot moods to flip the battlefield in your favor.</p>
          </article>
          <article class="feature">
            <h3>Clear Archetypes</h3>
            <p>Tsundere strikes, Kuudere control, Yandere deletion—distinct playstyles that stay balanced.</p>
          </article>
          <article class="feature">
            <h3>Collect • Trade • Flex</h3>
            <p>Open packs with animated reveals, complete sets, and trade safely in the hub.</p>
          </article>
          <article class="feature">
            <h3>Made for Web & Mobile</h3>
            <p>Responsive UI, touch-friendly layouts, and readable typography out of the box.</p>
          </article>
        </div>
      </div>
    </section>

    <section id="cards" class="cards-gallery">
      <div class="container">
        <h2 class="section-title">Card Spotlight</h2>
        <p class="cards-intro">Preview a sampling of Waifu archetypes—each colorful personality brings unique stats, moods, and tags to weave into your bond-driven strategy.</p>
        <div id="cards-status" class="cards-status" role="status" aria-live="polite">Loading card previews…</div>
        <div id="cards-grid" class="cards-grid" aria-live="polite"></div>
      </div>
    </section>

    <section class="callouts">
      <div class="container">
        <div class="callout">
          <div class="callout-copy">
            <h3>Meet the Archetypes</h3>
            <p>Learn the macro families—Passion Surge, Stoic Control, Heart Guard—and how they create soft matchups.</p>
            <a class="btn btn-secondary" href="#features">Explore Archetypes</a>
          </div>
        </div>
        <div class="callout alt">
          <div class="callout-copy">
            <h3>Build Your First Deck</h3>
            <p>Start with a Tsundere reactive shell or a Deredere support core—simple rules, deep strategy.</p>
            <a class="btn btn-secondary" href="#cards">See Cards</a>
          </div>
        </div>
      </div>
    </section>

  <section id="join" class="cta">
      <div class="container">
        <h2 class="section-title">Join The Journey</h2>
        <p>Follow development and get notified when the alpha opens.</p>
        <div class="cta-row">
          <a class="btn btn-primary" href="#">Join Waitlist</a>
          <a class="btn btn-ghost" href="#features">Learn More</a>
        </div>
      </div>
    </section>
  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <div>© <span id="year"></span> Waifu Wars TCG</div>
      <div class="footer-links">
  <a href="#join">Contact</a>
        <a href="https://github.com/CosmicPhoenix171/WaifuWarsTCG" target="_blank" rel="noopener">GitHub</a>
      </div>
    </div>
  </footer>

  <script type="module">
    const yearEl = document.getElementById('year');
    if (yearEl) yearEl.textContent = new Date().getFullYear();

    const cardsGrid = document.getElementById('cards-grid');
    const cardsStatus = document.getElementById('cards-status');

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

    const RARITY_META = {
      common: {
        key: 'common',
        datasetKey: 'common',
        name: 'Common',
        code: 'C',
        symbol: '●'
      },
      rare: {
        key: 'rare',
        datasetKey: 'rare',
        name: 'Rare',
        code: 'R',
        symbol: '★'
      },
      'super-rare': {
        key: 'super-rare',
        datasetKey: 'super-rare',
        name: 'Super Rare',
        code: 'SR',
        symbol: '★★'
      },
      'special-super-rare': {
        key: 'special-super-rare',
        datasetKey: 'special-super-rare',
        name: 'Special Super Rare',
        code: 'SSR',
        symbol: '★★★'
      },
      ultra: {
        key: 'ultra',
        datasetKey: 'ultra',
        name: 'Ultra Rare',
        code: 'UR',
        symbol: '✪'
      },
      event: {
        key: 'event',
        datasetKey: 'ultra',
        name: 'Event Exclusive',
        code: 'EX',
        symbol: '✪'
      }
    };

    function escapeHtml(str = '') {
      return String(str).replace(/[&<>"']/g, ch => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[ch]));
    }

    function capitalize(word = '') {
      return word.charAt(0).toUpperCase() + word.slice(1);
    }

    function formatSentences(text) {
      if (!text) return [];
      return String(text)
        .split(/(?:\r?\n|\r)+|(?<=[.!?])\s+/)
        .map(line => line.trim())
        .filter(Boolean);
    }

    function formatBonds(bonds) {
      if (!bonds) return '—';
      const start = typeof bonds.start === 'number' ? bonds.start : null;
      const max = typeof bonds.max === 'number' ? bonds.max : null;
      if (start !== null && max !== null) return `${start} / ${max}`;
      if (max !== null) return `${max}`;
      return '—';
    }

    function formatMood(mood) {
      if (!mood) return '— / —';
      const dere = mood.dere ?? '—';
      const extreme = mood.extreme ?? '—';
      return `${dere} / ${extreme}`;
    }

    function balanceAbilityText(root = document) {
      if (!root || typeof root.querySelectorAll !== 'function') return;
      root.querySelectorAll('.card-text-box').forEach((textBox) => {
        const abilities = textBox.querySelector('.card-abilities');
        if (!abilities) return;
        abilities.style.fontSize = '';
        let fontSize = parseFloat(getComputedStyle(abilities).fontSize) || 14;
        const minFontSize = 11;
        while (textBox.scrollHeight > textBox.clientHeight && fontSize > minFontSize) {
          fontSize -= 0.5;
          abilities.style.fontSize = `${fontSize}px`;
        }
      });
    }

    function syncCardHeight(article) {
      if (!article) return;
      const flipEl = article.querySelector('.card-flip');
      if (!flipEl) return;
      const front = flipEl.querySelector('.card-face--front');
      const back = flipEl.querySelector('.card-face--back');
      const frontHeight = front ? front.offsetHeight : 0;
      const backHeight = back ? back.offsetHeight : 0;
      const targetHeight = Math.max(frontHeight, backHeight);
      if (targetHeight) {
        flipEl.style.height = `${targetHeight}px`;
        flipEl.style.setProperty('--card-height', `${targetHeight}px`);
      }
    }

    let syncHeightsFrame = null;
    function scheduleSyncAllCardHeights(scope = document) {
      if (syncHeightsFrame) cancelAnimationFrame(syncHeightsFrame);
      syncHeightsFrame = requestAnimationFrame(() => {
        syncHeightsFrame = null;
        const root = scope instanceof Element ? scope : document;
        root.querySelectorAll('.card-display').forEach(syncCardHeight);
      });
    }

    function setupInteractiveCard(article) {
      const flipEl = article.querySelector('.card-flip');
      if (!flipEl) return;

      const state = {
        pointerId: null,
        startX: 0,
        startY: 0,
        isDragging: false,
        hasFlipped: false,
        isFlipped: flipEl.classList.contains('is-flipped'),
        resetTimer: null
      };

      article.setAttribute('aria-pressed', state.isFlipped ? 'true' : 'false');

      const maxTiltX = 10;
      const maxTiltY = 16;

      const updateCursorVars = (nx = 0, ny = 0) => {
        article.style.setProperty('--cursor-x', Number.isFinite(nx) ? nx.toFixed(3) : '0');
        article.style.setProperty('--cursor-y', Number.isFinite(ny) ? ny.toFixed(3) : '0');
      };
      updateCursorVars(0, 0);

      const resetTilt = (smooth = true) => {
        if (state.resetTimer) {
          clearTimeout(state.resetTimer);
          state.resetTimer = null;
        }
        if (smooth) {
          flipEl.style.transition = 'transform .26s ease, box-shadow .26s ease';
          flipEl.style.setProperty('--tilt-x', '0deg');
          flipEl.style.setProperty('--tilt-y', '0deg');
          flipEl.style.setProperty('--tilt-scale', '1');
          state.resetTimer = setTimeout(() => {
            flipEl.style.transition = '';
            state.resetTimer = null;
          }, 260);
        } else {
          flipEl.style.transition = '';
          flipEl.style.setProperty('--tilt-x', '0deg');
          flipEl.style.setProperty('--tilt-y', '0deg');
          flipEl.style.setProperty('--tilt-scale', '1');
        }
        updateCursorVars(0, 0);
      };

      const toggleFlip = () => {
        state.isFlipped = !state.isFlipped;
        flipEl.classList.toggle('is-flipped', state.isFlipped);
        article.setAttribute('aria-pressed', state.isFlipped ? 'true' : 'false');
      };

      const handleHoverTilt = (event) => {
        if (state.isDragging) return;
        const rect = flipEl.getBoundingClientRect();
        const relativeX = (event.clientX - rect.left) / rect.width;
        const relativeY = (event.clientY - rect.top) / rect.height;
        const tiltY = clamp((relativeX - 0.5) * 2 * maxTiltY, -maxTiltY, maxTiltY);
        const tiltX = clamp((0.5 - relativeY) * 2 * maxTiltX, -maxTiltX, maxTiltX);
        const normX = clamp((relativeX - 0.5) * 2, -1, 1);
        const normY = clamp((0.5 - relativeY) * 2, -1, 1);
        flipEl.style.setProperty('--tilt-x', `${tiltX.toFixed(2)}deg`);
        flipEl.style.setProperty('--tilt-y', `${tiltY.toFixed(2)}deg`);
        flipEl.style.setProperty('--tilt-scale', '1.02');
        updateCursorVars(normX, normY);
      };

      const handlePointerDown = (event) => {
        event.preventDefault();
        if (document.activeElement !== article && typeof article.focus === 'function') {
          article.focus({ preventScroll: true });
        }
        state.pointerId = event.pointerId;
        state.startX = event.clientX;
        state.startY = event.clientY;
        state.isDragging = true;
        state.hasFlipped = false;
        flipEl.setPointerCapture(event.pointerId);
        flipEl.classList.add('is-grabbing');
        flipEl.style.transition = '';
        flipEl.style.setProperty('--tilt-scale', '1');
        updateCursorVars(0, 0);
      };

      const handlePointerMove = (event) => {
        if (state.isDragging) {
          if (state.pointerId !== event.pointerId) return;
          const deltaX = event.clientX - state.startX;
          const deltaY = event.clientY - state.startY;

          if (!state.hasFlipped && Math.abs(deltaX) > 80 && Math.abs(deltaY) < 120) {
            toggleFlip();
            state.hasFlipped = true;
            resetTilt(false);
          } else if (!state.hasFlipped) {
            const dragTilt = clamp(deltaX / 12, -10, 10);
            flipEl.style.setProperty('--tilt-y', `${dragTilt.toFixed(2)}deg`);
          }
          const rect = flipEl.getBoundingClientRect();
          const relativeX = (event.clientX - rect.left) / rect.width;
          const relativeY = (event.clientY - rect.top) / rect.height;
          const normX = clamp((relativeX - 0.5) * 2, -1, 1);
          const normY = clamp((0.5 - relativeY) * 2, -1, 1);
          updateCursorVars(normX, normY);
        } else {
          handleHoverTilt(event);
        }
      };

      const handlePointerEnd = (event) => {
        if (state.pointerId !== event.pointerId) return;
        flipEl.releasePointerCapture(event.pointerId);
        state.pointerId = null;
        state.isDragging = false;
        flipEl.classList.remove('is-grabbing');
        resetTilt();
      };

      flipEl.addEventListener('pointerenter', handleHoverTilt);
      flipEl.addEventListener('pointermove', handlePointerMove);
      flipEl.addEventListener('pointerleave', () => {
        if (state.isDragging) return;
        resetTilt();
      });
      flipEl.addEventListener('pointerdown', handlePointerDown);
      flipEl.addEventListener('pointerup', handlePointerEnd);
      flipEl.addEventListener('pointercancel', handlePointerEnd);

      article.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          toggleFlip();
          resetTilt();
        }
      });

      resetTilt(false);
    }

    async function loadCards() {
      if (!cardsGrid || !cardsStatus) return;
      try {
        cardsStatus.hidden = false;
        cardsStatus.textContent = 'Loading card previews…';
        const res = await fetch('cards/index/by-type.json', { cache: 'no-store' });
        if (!res.ok) throw new Error(`Request failed: ${res.status}`);
        const data = await res.json();
        const waifus = Array.isArray(data?.waifu) ? data.waifu : [];

        if (!waifus.length) {
          cardsStatus.textContent = 'Card previews are coming soon.';
          return;
        }

        cardsStatus.textContent = '';
        cardsStatus.hidden = true;
        cardsGrid.innerHTML = '';

        const frag = document.createDocumentFragment();
        const interactiveArticles = [];

        const customCardBack = 'assets/images/card-back.png';
        const fallbackCardBack = 'assets/images/card-back-default.svg';

        for (const card of waifus) {
    const rarityKey = (card.rarity || 'common').toLowerCase();
  const rarityMeta = RARITY_META[rarityKey] || RARITY_META.common;
  const rarityDatasetKey = rarityMeta.datasetKey || rarityMeta.key;
  const rawRarityName = card.rarityName || rarityMeta.name;
  const rawRarityCode = card.rarityCode || rarityMeta.code;
  const rawRaritySymbol = card.raritySymbol || rarityMeta.symbol;
  const rarityName = escapeHtml(rawRarityName);
  const rarityCode = escapeHtml(rawRarityCode);
  const raritySymbol = escapeHtml(rawRaritySymbol);

    const typeLabel = capitalize(card.type || 'waifu');
          const abilityLines = formatSentences(card.text);
          const flavor = card.flavor ? card.flavor.replace(/^“|”$/g, '') : '';
          const moodDisplay = formatMood(card.mood);
          const bondsDisplay = formatBonds(card.bonds);
          const artDefault = card.art?.default;
          const backArt = card.art?.back || customCardBack;
          const hasArt = Boolean(artDefault);

          const artRole = hasArt ? `${card.name || 'Card'} artwork` : 'Card back artwork';
          const artMarkup = hasArt
            ? `<img src="${artDefault}" alt="">`
            : `<img src="${backArt}" alt="Waifu Wars card back" class="card-art-img-back" onerror="this.onerror=null;this.src='${fallbackCardBack}';">`;

          const cardTitle = escapeHtml(card.name || 'Unnamed Card');
          const typeDescriptor = card.archetype ? `${typeLabel} — ${card.archetype}` : typeLabel;
          const typeDescriptorEsc = escapeHtml(typeDescriptor);
          const archetypeChip = escapeHtml((card.archetype || typeLabel).toUpperCase());
          const moodDisplayEsc = escapeHtml(moodDisplay);
          const bondsDisplayEsc = escapeHtml(bondsDisplay);
          const setLabel = escapeHtml(card.set || 'TBA');
          const idLabel = escapeHtml((card.id || '').toUpperCase());
          const artRoleEsc = escapeHtml(artRole);

          const tagsHtml = (card.tags || [])
            .map(tag => `<span class="card-tag">${escapeHtml(tag)}</span>`)
            .join('');

          const abilitiesHtml = abilityLines.length
            ? abilityLines.map(line => `<li>${escapeHtml(line)}</li>`).join('')
            : '<li class="card-ability-empty">Ability text coming soon.</li>';

          const flavorHtml = flavor
            ? `<p class="card-flavor">“${escapeHtml(flavor)}”</p>`
            : '';

          const frontHtml = `
            <div class="card-frame">
              <header class="card-header">
                <span class="card-rarity-badge">
                  <span class="card-rarity-symbol" aria-hidden="true">${raritySymbol}</span>
                  <span class="sr-only">${rarityName} rarity</span>
                  <span class="card-rarity-code">${rarityCode}</span>
                </span>
                <h3 class="card-title">${cardTitle}</h3>
                <span class="card-aff-chip">${card.affection ?? '—'}</span>
              </header>
              <div class="${hasArt ? 'card-art' : 'card-art card-art--back'}" role="img" aria-label="${artRoleEsc}">
                ${artMarkup}
              </div>
              <div class="card-type-row">
                <span class="card-type-label">${typeDescriptorEsc}</span>
                <span class="card-archetype-chip">${archetypeChip}</span>
              </div>
              <div class="card-text-box">
                <ul class="card-abilities">
                  ${abilitiesHtml}
                </ul>
                ${flavorHtml}
              </div>
              <dl class="card-statline">
                <div>
                  <dt>Affection</dt>
                  <dd>${card.affection ?? '—'}</dd>
                </div>
                <div>
                  <dt>Bonds</dt>
                  <dd>${bondsDisplayEsc}</dd>
                </div>
                <div>
                  <dt>Mood</dt>
                  <dd>${moodDisplayEsc}</dd>
                </div>
              </dl>
              <div class="card-set-emblem" aria-label="Set ${setLabel}">
                <span class="card-set-icon" aria-hidden="true"></span>
                <span class="card-set-text">Set ${setLabel}</span>
              </div>
              <div class="card-tags" aria-label="Card tags">
                ${tagsHtml || '<span class="card-tag card-tag-empty">No tags yet</span>'}
              </div>
              <footer class="card-footer">Set ${setLabel} • ${idLabel}</footer>
            </div>
          `;

          const backHtml = `
            <div class="card-back-frame" aria-hidden="true">
              <div class="card-back-art">
                <img src="${backArt}" alt="Waifu Wars card back" onerror="this.onerror=null;this.src='${fallbackCardBack}';">
              </div>
            </div>
          `;

          const article = document.createElement('article');
          article.className = 'card-display';
          article.dataset.rarity = rarityDatasetKey;
          article.dataset.rarityTier = rarityMeta.key;
          if (card.archetype) {
            article.dataset.archetype = card.archetype.toLowerCase();
          }
          if (card.id) {
            article.dataset.cardId = card.id;
          }
          if (rarityKey === 'event') {
            article.dataset.rarityVariant = 'event';
          }
          const rarityTheme = (card.rarityTheme || '').toLowerCase();
          if (rarityTheme) {
            article.dataset.rarityTheme = rarityTheme;
          }
          if (card.rarityCode) {
            article.dataset.rarityCode = rawRarityCode;
          }
          if (card.rarityName) {
            article.dataset.rarityName = rawRarityName;
          }
          article.setAttribute('role', 'button');
          article.setAttribute('tabindex', '0');
          article.setAttribute('aria-pressed', 'false');
          article.setAttribute('aria-label', `${card.name || 'Card'} preview. Drag sideways to flip.`);
          article.style.setProperty('--cursor-x', '0');
          article.style.setProperty('--cursor-y', '0');

          article.innerHTML = `
            <div class="card-flip">
              <div class="card-face card-face--front">
                ${frontHtml}
              </div>
              <div class="card-face card-face--back">
                ${backHtml}
              </div>
            </div>
          `;

          frag.appendChild(article);
          interactiveArticles.push(article);
        }

        cardsGrid.appendChild(frag);

        balanceAbilityText(cardsGrid);
        scheduleSyncAllCardHeights(cardsGrid);
        requestAnimationFrame(() => {
          interactiveArticles.forEach((article) => {
            syncCardHeight(article);
            setupInteractiveCard(article);
          });
        });
      } catch (err) {
        cardsStatus.textContent = 'Could not load cards right now. Try refreshing in a moment.';
        cardsStatus.hidden = false;
        console.error(err);
      }
    }

    window.addEventListener('resize', () => {
      balanceAbilityText(cardsGrid);
      scheduleSyncAllCardHeights(cardsGrid);
    });

    if (document.fonts && typeof document.fonts.ready?.then === 'function') {
      document.fonts.ready.then(() => scheduleSyncAllCardHeights(cardsGrid)).catch(() => {});
    }

    loadCards();
  </script>
</body>
</html>
